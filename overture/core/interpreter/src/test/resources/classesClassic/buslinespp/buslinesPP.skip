class Bus
    
    instance variables
        seats : set of Passenger;
        inv card seats <= Config`BusCapacity;
        
        --bus line number
        line : nat;

        -- the route of road the bus is moving along
        route : seq of Road;
        -- what roads are left in the current pass of the route
        curRoute : seq of Road;
        -- where are we heading
        nextWP : Waypoint;
        -- what road are we currently on
        currentRoad : Road;
        --waypoints passed by the bus
        wps : seq of Waypoint;
        
    operations
        public Bus : nat * seq of Road * seq of Waypoint ==> Bus
        Bus(linenumber, busroute, waypoints)==
        (
            line := linenumber;
            route := busroute;
            curRoute := busroute;
            nextWP := hd waypoints;         

            wps := waypoints;
            seats := {};
        )
        pre len waypoints > 1; --ensure bus has somewhere to go

        public GetOn : set of Passenger ==> ()
        GetOn(ps) == 
        (
            seats := seats union ps;
            World`graphics.busPassengerCountChanged(line, card seats);
        )
        pre card seats + card ps <= Config`BusCapacity; 

        public GotOff : set of Passenger ==> ()
        GotOff(p) ==    
        (
            seats := seats \ p;
            World`graphics.busPassengerCountChanged(line, card seats);
        )
        pre p inter seats <> {};

        public GetWaypoints : () ==> seq of Waypoint
        GetWaypoints()== 
            return wps;

        public GetStops : () ==> seq of Busstop
        GetStops()== 
            return [wps(i) | i in set inds wps & wps(i).IsStop() ];
        

        private NextWaypoint : () ==> Waypoint
        NextWaypoint()== 
        (   
            --start route over
            if(len curRoute = 0) then
                curRoute := route;

            --next road
            let nextRoad = hd curRoute in 
            (
                --move along route
                curRoute := tl curRoute;
                --what road are we on
                currentRoad := nextRoad;
                -- update waypoints
                let currentWp = nextWP  in
                (
                    nextWP := currentRoad.OppositeEnd(currentWp);
                    return currentWp;
                )
            );
        );

        --functionality to ensure thread start
        public WaitForThreadStart : () ==> ()
        WaitForThreadStart() == skip;

        private ThreadStarted : () ==> ()
        ThreadStarted() == skip;

    sync
        per GetOn => card seats < Config`BusCapacity;
        per WaitForThreadStart => #fin(ThreadStarted) > 0
    
    thread
    (
        dcl passGettingOn : set of Passenger;
        ThreadStarted();
        let - = NextWaypoint() in skip; --prevent return

        --loop which moves bus along route, and lets passengers on and off at stops
        while true do
        (
            Printer`OutWithTS("%Bus " ^ Printer`natToString(line) ^ ": running on " ^ 
                                    VDMUtil`val2seq_of_char[Road`RoadNumber](currentRoad.GetRoadNumber()) ^
                                    " with length " ^ Printer`natToString(currentRoad.GetLength()) ^ " and speedlimit " ^
                                     Printer`natToString(currentRoad.GetSpeedLimit()) ^
                                     " Next: " ^ VDMUtil`val2seq_of_char[Waypoint`WaypointsEnum](nextWP.GetId()) ^
                                     " Time: " ^ Printer`natToString(currentRoad.GetTimePenalty())
                            );
 
            World`graphics.busInRouteTo(line,
                VDMUtil`val2seq_of_char[Road`RoadNumber](currentRoad.GetRoadNumber()), 
                VDMUtil`val2seq_of_char[Waypoint`WaypointsEnum](nextWP.GetId()),
                currentRoad.GetTimePenalty());

            --add to penalty for moving along road
            World`timerRef.WaitRelative(currentRoad.GetTimePenalty());
            World`timerRef.NotifyAll();
            World`timerRef.Awake();

            --next on bus route
            let next = NextWaypoint() in
            (   
                Printer`OutWithTS("%Bus " ^ Printer`natToString(line) ^ 
                " arrived at " ^ 
                VDMUtil`val2seq_of_char[Waypoint`WaypointsEnum](next.GetId()));

                let nextId = next.GetId() in
                ( 
                    --let passengers in at central station if 
                    --their destination is on the bus' route
                    if nextId = <Central> then
                    (
                        --bus returned with passengers; in the current model this should not be possible
                        --if(seats <> {}) then exit "Bus returned with passengers";
                        
                        let central : Busstop = next in
                        ( 
                            --find passengers for bus
                            let potentialPassengers : set of Passenger = central.GetWaitingOn(wps) in 
                            (
                                if(card potentialPassengers > 0) then
                                (
                                    --count available sets in bus
                                    if((Config`BusCapacity - card seats) < card potentialPassengers) then 
                                        --not room for all, select some
                                        passGettingOn := SelectSubset(potentialPassengers, Config`BusCapacity - card seats)
                                    else
                                        passGettingOn := potentialPassengers;
                                    
                                    -- leave busstop and enter bus seats
                                    central.PassengerLeft(passGettingOn);
                                    GetOn(passGettingOn);
                                    for all p in set passGettingOn do p.GotOnBus();

                                    Printer`OutWithTS("%Bus " ^ Printer`natToString(line) ^ ": " ^ 
                                        Printer`natToString(card passGettingOn) ^ " got on");

                                    --add to time penalty for stopping
                                    World`graphics.busStopping(line);
                                    World`timerRef.WaitRelative(3);
                                    World`timerRef.NotifyAll();
                                    World`timerRef.Awake();
                                )
                            );
                        );
                    );                  

                    -- let passengers off at their destination
                    let gettingOff = { p | p in set seats & p.GetDestination() = next} in
                    (
                            if(card gettingOff > 0) then
                            (
                                GotOff(gettingOff);
                                Printer`OutWithTS("%Bus " ^ Printer`natToString(line) ^ ": " ^ 
                                    Printer`natToString(card gettingOff) ^ " got off");
                                
                                World`env.TransportedPassengers(card gettingOff);

                                --add to time penalty for stopping
                                World`graphics.busStopping(line);
                                World`timerRef.WaitRelative(3);
                                World`timerRef.NotifyAll();
                                World`timerRef.Awake();
                            );
                    );
                );
            );

        );
    );

    operations
        private SelectSubset : set of Passenger * nat ==> set of Passenger
        SelectSubset(ps, limit)==
        (
            --base case
            if limit = 0 then 
                return {};

            --smaller than limit, return
            if card ps <= limit then 
                return ps;

            --recusive
            let sub in set ps in
                    return {sub} union SelectSubset(ps \ {sub}, limit -1); 
        )

end Bus

class Busstop is subclass of Waypoint

    instance variables
        waiting : set of Passenger := {};

    operations
        public Busstop : Waypoint`BusStops ==> Busstop
        Busstop(s) == 
        (
            id := s;
            isStop := true;
        );

        --number of passenger waiting
        public GetWaitingCount : () ==> nat
        GetWaitingCount() ==
            return card waiting;
        
        --get passengers waiting
        public GetWaiting : () ==> set of Passenger
        GetWaiting() ==
            return waiting;

        -- get passengers waiting on a bus which passes specific stops 
        public GetWaitingOn : seq of Waypoint==> set of Passenger
        GetWaitingOn(stopsAt)==
            let stops = elems stopsAt in
            return  {p | p in set waiting & {p.GetDestination()} inter stops <> {}};

        --passenger arrived at the busstop
        public AddPassenger : Passenger ==> ()
        AddPassenger(p) == 
            waiting := waiting union {p}; 
        
        --passenger got on a bus
        public PassengerLeft : set of Passenger ==> ()
        PassengerLeft(p) ==
            waiting := waiting \ p
        pre p inter waiting <> {};

sync
    ---protect waiting instance variable
    mutex(GetWaitingCount, AddPassenger, PassengerLeft)

end Busstop

class City

    instance variables
        wayspoints : set of Waypoint := {};
        
        stops : inmap Waypoint`BusStops to Busstop := {|->};    
        roads : inmap Road`RoadNumber to Road := {|->}; 
        buses : inmap nat to Bus := {|->};
        central : Busstop;
        inflow : nat; 

    operations
        public City : () ==> City
        City()== 
        (
            central := addBusstop(<Central>);
            inflow := 1; --default inflow value
        );      

        
        --add a new busStop to the city
        public addBusstop : Waypoint`BusStops ==> Busstop 
        addBusstop(stp) == 
        (
            let bs = new Busstop(stp) in 
            (
                stops := stops munion {stp|->bs};
                wayspoints := wayspoints union {bs};
                return bs
            )
        )
        pre stp not in set dom stops; 


        --add waypoint to the city, pasengers can not get off at a waypoint
        public addWaypoint : Waypoint`WaypointsEnum ==> Waypoint 
        addWaypoint(stp) == 
        (
            let wp = new Waypoint(stp) in 
            (
                wayspoints := wayspoints union {wp};
                return wp;
            )
        )
        pre stp not in set dom stops;


        --add road to the city, a road are end to end and must have to waypoints and a roadnumber 
        -- the length of the road has significance to travel time of the bus
        public addRoad : Waypoint * Waypoint * Road`RoadNumber * nat ==> ()
        addRoad(wp1, wp2, roadNmbr, length) ==  
        (
            let r = new Road(roadNmbr, {wp1, wp2}, length) in
            (
                roads := roads munion {roadNmbr |-> r};
            );
        )
        pre roadNmbr not in set dom roads --road number not used before
        and wp1 <> wp2  --not the same wp, a road to the same wp is not a road
        and forall r in set rng roads & not r.Covers({wp1, wp2}); --  waypoint not connected before



        --overloaded addRoad, which allows for the speedlimit of the road to be change from
        -- the default value
        public addRoad : Waypoint * Waypoint * Road`RoadNumber * nat * nat==> ()
        addRoad(wp1, wp2, roadNmbr, length ,speedlimit) ==  
        (
            let r = new Road(roadNmbr, {wp1, wp2}, length, speedlimit) in
            (
                roads := roads munion {roadNmbr |-> r};     
            )
        )
        pre roadNmbr not in set dom roads --road number not used before
        and forall r in set rng roads & not r.Covers({wp1, wp2}) --  waypoint not connected before
        and wp1 <> wp2; --not the same wp, a road to the same wp is not a road

        --add a new bus with a particular road 
        public addBus : nat * seq of Road`RoadNumber ==> Bus
        addBus(lineNumber, route)==
        (
            --validate that route is possible and finds waypoints along route   
            dcl busstops : seq of Waypoint := [];
            dcl currentWP : Waypoint;
            --find roads from ids
            let busRoads = findRoadsFromRoadNumber(route) in
            (
                    --always start from central
                    currentWP := central;
                    busstops := [currentWP];

                    --find busstops on the route, starting from central
                    for all i in set inds busRoads do
                    (
                        --stepwise move along route
                        currentWP := busRoads(i).OppositeEnd(currentWP);
                        busstops := busstops ^ [currentWP];
                    );
                                

                if (hd busstops <> busstops(len(busstops))) then
                    exit "End not the same as start "; --change to pre? 
                
                --creat bus 
                let bus = new Bus(lineNumber, busRoads, busstops) in 
                (
                    --add to mapping
                    buses := buses munion {lineNumber |-> bus};
                    --
                    World`graphics.busAdded(lineNumber);
                    return bus;
                )   
            );
        )
        pre len route > 1 --there actually is a route
        and lineNumber not in set rng buses; --bus linenumber is not known


        private findRoadsFromRoadNumber : seq of Road`RoadNumber ==> seq of Road
        findRoadsFromRoadNumber(route)==  
                return [roads(route(i)) | i in set inds route]; 


        public getCentralStation : () ==> Busstop
        getCentralStation()== 
            return central;

        --passenger inflow
        public setInflow : nat ==> ()
        setInflow(flow) ==  
        (           
            inflow := flow;
            World`graphics.inflowChanged(inflow);
        );

        public getInflow : () ==> nat
        getInflow()==
            return inflow;

        public getBuses : () ==> set of Bus
        getBuses()==
            return rng buses;
        
        --sync functionality for ensuring thread is started, 
        --due to lack of thread scheduling fairness
        public WaitForThreadStart : () ==> ()
        WaitForThreadStart() == skip;

        private ThreadStarted : () ==> ()
        ThreadStarted() == skip;

    sync
        --mutex(setInflow);
        --mutex(setInflow, getInflow);
        per WaitForThreadStart => #fin(ThreadStarted) > 0

    thread
    (
        ThreadStarted();
        while true do
        (
            --add passengers to central station
                for all - in set {1,...,getInflow()} do
                (
                    --random find stop for passenger to get off
                    let stopSeq = VDMUtil`set2seq[Waypoint`BusStops](dom stops) in  --TODO exclude central
                        let i = MATH`rand(World`timerRef.GetTime()) mod len stopSeq  in
                            let pass = new Passenger(stops(stopSeq(i+1))) in 
                            (
                                --let pass = new Passenger(stops(<A>)) in --TODO
                                central.AddPassenger(pass);
                                World`graphics.passengerAtCentral(pass.Id(), 
                                    VDMUtil`val2seq_of_char[Waypoint`WaypointsEnum]
                                    (pass.GetDestination().GetId()));
                            )
                );

            World`env.handleEvent(Printer`natToString(central.GetWaitingCount()) ^ " passengers waiting a central station");
            
            --check annoyance of waiting passengers
            for all pass in set central.GetWaiting() do
                pass.AnnoyedOfWaiting();

            World`timerRef.WaitRelative(5);
            World`timerRef.NotifyAll();
            World`timerRef.Awake();
        ) 
    )

end City

class ClockTick

thread 
    while true do
    (
        World`timerRef.WaitRelative(1);
        World`timerRef.NotifyAll();
        World`timerRef.Awake();
    )

 end ClockTick
 
 -----------------------------------------------
-- Class:           Config
-- Description:     Config contains configuration values
-----------------------------------------------

--
-- class definition
--
class Config

--
-- Values definition section
--
values

--max passengers on bus
public static BusCapacity : nat = 15;
--speed limit on road, buses will always drive to the limit         
public static DefaultRoadSpeedLimit : nat = 10;             
--amount of waiting time beofre passengers become annoyed
public static PassengerAnnoyanceLimit : nat = 40;       
--max value of passengers inflow 
public static MaxInflow : nat = 10;     

end Config

-----------------------------------------------
-- Class:           Environment
-- Description:     Environment class in the VeMo project
-----------------------------------------------

--
-- class definition
--
class Environment

instance variables

    public city : City;
    private io : IO := new IO();
    private inlines : seq of inline := [];
    private outlines : seq of char := [];
    private busy : bool := true;
    private simulating : bool := false;

    private passengersTransported : nat := 0;
    private passengersAnnoyed : nat := 0;
    private passengersCount : nat :=0;
    private passengersAnnoyedStops :  map Waypoint`WaypointsEnum to nat := {|->};

types   
    inline  = Types`Event;
    InputTP   = seq of inline;

operations

    public Environment: seq of char ==> Environment
    Environment(filename) ==
    (
        city := new City();

        inlines := [
--mk_Types`BusRoute(1, [<R8>,<R15>,<R10>,<R9>], 1), -- normal route works
--mk_Types`BusRoute(1, [<R8>,<R15>,<R4>,<R9>], 1), --R4 and R15 not connected --fails
--mk_Types`BusRoute(1, [<R4>,<R1>,<R3>,<R9>], 1),   -- not starting at central --fails
--mk_Types`BusRoute(1, [<R8>,<R7>,<R7>,<R8>], 1),   -- return by the same route -- works
mk_Types`BusRoute(2, [<R9>,<R12>,<R13>,<R2>,<R1>,<HW1>], 1),
mk_Types`BusRoute(7, [<R8>,<R15>,<R11>,<R14>,<R13>,<R12>,<R9>], 1), 
mk_Types`BusRoute(57, [<HW1>, <R4>, <R5>, <R7>, <R8>], 1),  
--mk_Types`BusRoute(3, [<R9>,<R16>,<R2>,<R1>,<R1>,<R2>,<R16>,<R9>], 1), 
mk_Types`Inflow(1, 3),
mk_Types`Simulate(5),  
mk_Types`Inflow(3, 75),
mk_Types`Inflow(5, 125),
mk_Types`Inflow(0, 150),
mk_Types`WasteTime(220)
];
--      def mk_(-,input) = io.freadval[InputTP](filename) in
--      (
--          inlines := input;
--      );   

        BuildCityMap();
    );

    private BuildCityMap : () ==> ()
    BuildCityMap() ==
    (
        dcl a : Busstop, b : Busstop, c : Busstop, d : Busstop, e : Busstop, f :Busstop;
        dcl wp1 : Waypoint, wp2 : Waypoint, wp3 : Waypoint, wp4 : Waypoint;

        a := city.addBusstop(<A>);
        b := city.addBusstop(<B>);
        c := city.addBusstop(<C>);
        d := city.addBusstop(<D>);
        e := city.addBusstop(<E>);
        f := city.addBusstop(<F>);

        wp1 := city.addWaypoint(<WP1>);
        wp2 := city.addWaypoint(<WP2>);
        wp3 := city.addWaypoint(<WP3>);
        wp4 := city.addWaypoint(<WP4>);
        
        city.addRoad(a, b, <R1>, 40);
        city.addRoad(b, wp1, <R2>, 80);
        city.addRoad(b, wp2, <R3>, 50);
        city.addRoad(a, wp2, <R4>, 90);
        city.addRoad(wp2, c, <R5>, 60);
        city.addRoad(c, d, <R6>, 40);
        city.addRoad(c, f, <R7>, 60);
        city.addRoad(f, city.getCentralStation(), <R8>, 100);
        city.addRoad(city.getCentralStation(), wp3, <R9>, 50);
        city.addRoad(wp3, wp4, <R10>, 30);
        city.addRoad(d, wp4, <R11>, 40);
        city.addRoad(wp3, e, <R12>, 40);
        city.addRoad(e, wp1, <R13>, 40);
        city.addRoad(wp1, d, <R14>, 30);
        city.addRoad(f, wp4, <R15>, 20);
        city.addRoad(wp1, wp3, <R16>, 40);
        city.addRoad(a, city.getCentralStation(), <HW1>, 310, Config`DefaultRoadSpeedLimit + 10);
    );  

  
    public Events: () ==> ()
    Events() ==
    (
       if inlines <> []
       then 
       (  
        dcl done : bool := false, 
        eventOccurred : bool := false,
        curtime : Types`Time := World`timerRef.GetTime();
    
        while not done do
        (
         def event = hd inlines in      
            cases event:
                mk_Types`BusRoute(-,-,-) ->
                (
                    if event.t <= curtime
                    then
                    (
                        Printer`OutWithTS("Environment: Bus route "
                                             ^ Printer`natToString(event.ID)); 

                        let b = city.addBus(event.ID, event.route) in  
                        ( 
                            Printer`Out("Waypoints:");
                            let wps = b.GetWaypoints() in 
                                let wpsIds = [wps(i).GetId() | i in set inds wps] in 
                                    IO`print(wpsIds);

                            Printer`Out("\nStops:");

                            let wps = b.GetStops() in 
                                let wpsIds = [wps(i).GetId() | i in set inds wps] in 
                                    IO`print(wpsIds);
                            Printer`Out("\n");
                        );

                         eventOccurred := true;
                    )
                ),
                mk_Types`Inflow(-,-) ->
                (
                    if event.t <= curtime
                    then
                    (
                        SetInflow(event.flow);
                        
                        eventOccurred := true;
                     )
                ),
                mk_Types`Simulate(-) ->
                (
                    if event.t <= curtime
                    then
                    (
                        if not simulating then
                        (
                            Printer`OutWithTS("Environment: " 
                                          ^ "Simulation started");
                            simulating := true;
                            start(city);
                            city.WaitForThreadStart();
                            for all bus in set city.getBuses() do 
                            (
                                start(bus);
                                bus.WaitForThreadStart();
                            );

                        ); 
                        eventOccurred := true;
                    ) 
                ),
                mk_Types`WasteTime(-) ->
                (
                    if event.t <= curtime
                    then
                    (       
                     Printer`OutWithTS("Environment: Wasting time");        
                     eventOccurred := true;
                    )
                ),
                others -> Printer`OutWithTS("Environment: No match found")
            end;
    
            if eventOccurred then
            (
                inlines := tl inlines;
                done := len inlines = 0;  
            ) 
            else 
                done := true;
              
            eventOccurred := false;
            );
          )
          else busy := false;
    );
   
    public handleEvent : seq of char ==> ()
    handleEvent(s) ==
    (
       Printer`OutWithTS("#Environment handled System Event: " ^ s);
       outlines := outlines ^ Printer`natToString(World`timerRef.GetTime()) ^ ": " ^ s ^ "\n"; 
    );

    private SetInflow : nat  ==> ()
    SetInflow(flow)== 
    (
        Printer`OutWithTS("Environment: " 
          ^ "Inflow changed to " ^ Printer`natToString(flow));
                     
        city.setInflow(flow);
    );

    public IncreaseInflow : () ==> ()
    IncreaseInflow() ==
    (
        let flow = city.getInflow() in 
        (
            if(flow < Config`MaxInflow) then
                SetInflow(flow +1);
        )
    );

    public DecreaseInflow : () ==> ()
    DecreaseInflow() ==
    (
        let flow = city.getInflow() in 
        (
            if(flow > 0) then
                SetInflow(flow -1);
        )
    );

    public TransportedPassengers : nat ==> ()
    TransportedPassengers(number)== 
        passengersTransported := passengersTransported + number;

    --public AnnoyedPassenger : nat * Waypoint`WaypointsEnum ==> ()
    --AnnoyedPassenger(number, waypoint)== 
    public AnnoyedPassenger : nat * Waypoint`WaypointsEnum ==> ()
    AnnoyedPassenger(number, goal)==
    (
        passengersAnnoyed := passengersAnnoyed + number;

        if(goal not in set dom passengersAnnoyedStops) then 
        (
            passengersAnnoyedStops := passengersAnnoyedStops ++ {goal |-> number};
        )
        else
            passengersAnnoyedStops := passengersAnnoyedStops ++ {goal |-> passengersAnnoyedStops(goal) + number};
    );

    public PassengerCount : () ==> ()
    PassengerCount()== 
        passengersCount := passengersCount + 1;
    
    public report : () ==> ()
    report() ==
    (
        Printer`Out("\n\nHowever beautiful the strategy," ^ 
                        " you should occasionally look at the results.");
        Printer`Out("**************RESULT**************");
        Printer`Out("**********************************");
        --Printer`Out(outlines);
        Printer`Out(" " ^ VDMUtil`val2seq_of_char[nat](passengersCount) ^ "\t passengers in total. (transported and at central)");  
        Printer`Out(" " ^ VDMUtil`val2seq_of_char[nat](passengersTransported) ^ "\t passengers transported.");
        Printer`Out(" " ^ VDMUtil`val2seq_of_char[nat](passengersAnnoyed) ^ "\t passengers got annoyed.");  

        
        for all waypoint in set dom passengersAnnoyedStops do
        (   
            Printer`Out("\t" ^ VDMUtil`val2seq_of_char[Waypoint`WaypointsEnum](waypoint) ^ " : " ^ VDMUtil`val2seq_of_char[nat](passengersAnnoyedStops(waypoint)));

        );
        Printer`Out("\n**********************************");
        Printer`Out("**********************************");
    );
   
    public isFinished : () ==> () 
    isFinished() == skip;

    public goEnvironment : () ==> () 
    goEnvironment() == skip;

    public run : () ==> ()
    run() ==
    (
        start(self);
    );

thread
(
    start(new ClockTick());
    while busy do
    (
        Events();
        World`timerRef.WaitRelative(0);
        World`timerRef.NotifyAndIncTime();
        World`timerRef.Awake();
        World`graphics.move();
        World`graphics.sleep();
    );
 
    Printer`Out("No more events;");
)

sync
    per isFinished => not busy;
    mutex(handleEvent)

end Environment

class gui_Graphics
    operations

        public init : () ==> ()
        init() == is not yet specified;
    
        public busInRouteTo : nat * seq of char * seq of char * nat ==> ()
        busInRouteTo(busid, roadid, waypoint, time) == is not yet specified; 
    
        public move : () ==> ()
        move() == is not yet specified;

        public sleep : () ==> ()
        sleep() == is not yet specified;
    
        public passengerAtCentral : nat * seq of char  ==> ()
        passengerAtCentral(id, waypoint) == is not yet specified;

        public passengerAnnoyed : nat==> ()
        passengerAnnoyed(id) == is not yet specified;
    
        public passengerGotOnBus : nat ==> ()
        passengerGotOnBus(id) == is not yet specified;

        public inflowChanged : nat ==> ()
        inflowChanged(id) == is not yet specified;

        public busAdded : nat ==> ()
        busAdded(id) == is not yet specified;

        public busStopping : nat ==> ()
        busStopping(id) == is not yet specified;

        public busPassengerCountChanged : nat * nat ==> ()
        busPassengerCountChanged(busid, count) == is not yet specified;

end gui_Graphics

class Passenger

    instance variables
        static nextPassengerId : nat := 1;

        passengerId : nat;
        goal :  Waypoint;
        inv goal.IsStop() = true;       

        annoyanceLimit : nat;
        pickedUp : bool;
        alreadyAnnoyed : bool;

    operations
        public Passenger : Busstop==> Passenger 
        Passenger(destination) == 
        (
            passengerId := GetNextId();
            goal := destination;
            annoyanceLimit := World`timerRef.GetTime() + Config`PassengerAnnoyanceLimit;
            pickedUp := false;
            alreadyAnnoyed := false;

            World`env.PassengerCount();
        )
        pre destination.IsStop() = true;
        
        public GetDestination : () ==>  Waypoint
        GetDestination()== 
            return goal;

        public GotOnBus : () ==> () 
        GotOnBus()== 
        (
            World`graphics.passengerGotOnBus(passengerId);
            pickedUp := true;
        );

        public IsAnnoyedOfWaiting : () ==> bool
        IsAnnoyedOfWaiting() == return annoyanceLimit < World`timerRef.GetTime() 
                                    and not pickedUp;

        -- report to environment when  passenger becomes annoyed.
        public AnnoyedOfWaiting : () ==> ()
        AnnoyedOfWaiting() == 
        (
            if(IsAnnoyedOfWaiting() and not alreadyAnnoyed) then
            (
                alreadyAnnoyed := true;
                World`env.handleEvent("Passenger " ^ Printer`natToString(passengerId) ^ " heading for " ^ 
                 VDMUtil`val2seq_of_char[Waypoint`WaypointsEnum](goal.GetId()) ^ " is annoyed of waiting.");            
                World`env.AnnoyedPassenger(1, goal.GetId());
                World`graphics.passengerAnnoyed(passengerId);
            )
        );

        public Id : () ==> nat
        Id()== 
            return passengerId;
    
        private GetNextId : () ==> nat
        GetNextId() ==
        (
            let pid = nextPassengerId 
            in 
            (
                nextPassengerId := nextPassengerId +1;
                return pid;
            )

        );

    sync
        mutex(GotOnBus, AnnoyedOfWaiting);

end Passenger

class Printer

    operations      
        public static Out: seq of char ==> ()
         Out (pstr) ==
           def - = new IO().echo(pstr ^ "\n") in skip;
            
        
        public static natToString : nat ==> seq of char 
        natToString(n) ==
        (
            return VDMUtil`val2seq_of_char[nat](n);
        );

          
        public static OutWithTS: seq of char ==> ()
        OutWithTS (pstr) ==
            def - = new IO().echo(Printer`natToString(World`timerRef.GetTime()) ^": " ^ pstr ^ "\n") in skip;


        public static intToString : int ==> seq of char 
        intToString(i) ==
        (
            return VDMUtil`val2seq_of_char[int](i);
        );

end Printer

class Road
    types
        public RoadNumber = <R1> | <R2> | <R3> | <R4> | <R5> | <R6> | <R7> | <R8> 
            | <R9> | <R10> | <R11> | <R12> | <R13> |<R14> | <R15> | <R16> | <HW1>;
    values

    instance variables
        roadNmbr  : RoadNumber;     
        roadLength : nat;
        speedlimit : nat;
        wps : set of Waypoint := {};
        timePenalty : nat;
        inv card wps > 1;

    operations
        public Road : RoadNumber * set of Waypoint * nat ==> Road
        Road(roadnumber, waypoints, length) ==
        (
            atomic 
            (
            roadNmbr := roadnumber;
            roadLength := length;
            speedlimit := Config`DefaultRoadSpeedLimit;
            wps := waypoints;
            timePenalty := floor(roadLength / speedlimit);
            )
        )
        pre card waypoints > 1;

        public Road : RoadNumber *  set of Waypoint * nat * nat ==> Road
        Road(roadnumber, waypoints, length, limit) ==
        (
            roadNmbr := roadnumber;
            roadLength := length;
            speedlimit := limit;
            wps := waypoints;
            --time cost of driving on the road
            timePenalty := floor(roadLength / speedlimit);
        )
        pre card waypoints > 1;

        public Covers : set of Waypoint ==> bool
        Covers(waypoints) == 
             return {w.GetId() | w in set waypoints} = {w.GetId() | w in set wps};  --does road cover the waypoints in arg

        public GetWaypoints : () ==> set of Waypoint
        GetWaypoints()==
                return wps;

        public OppositeEnd : Waypoint ==> Waypoint
        OppositeEnd(wp)==
                 let opposite in set wps \ {wp} in return opposite
        pre wp in set wps;  -- if the waypoint is not found on the road
                        -- it may indicate that the route is not connected 
                        -- by the same waypoint

        
        public GetSpeedLimit : () ==> nat
        GetSpeedLimit()==
                return speedlimit;

        public GetLength : () ==> nat
        GetLength() == 
            return roadLength;

        public GetRoadNumber : () ==> RoadNumber
        GetRoadNumber()== 
                return roadNmbr;

        public GetTimePenalty : () ==> nat
        GetTimePenalty()== 
                return timePenalty;

end Road

\begin{vdm_al}
class TimeStamp

\end{vdm_al}
Class used for concurrent VDM++ models. All threads should call the following operations:
- WaitRelative(t): makes the thread periodic with t = the period
- NotifyAll(): notified all threads sleeping in the wakeUpMap
- Awake(): puts the thread to sleep - will wakeup when t time units has passed  
\begin{vdm_al}

values

\end{vdm_al}
The step length with which the currentTime is incremented
\begin{vdm_al}

public stepLength : nat = 1;

instance variables

currentTime  : nat   := 0;
wakeUpMap    : map nat to nat := {|->};
--syncWithTimeInc : set of nat := {};
--syncWithTimeIncCurrent : set of nat := {};

operations

\end{vdm_al}
WaitRelative: sleeps the calling thread for 'val' time units - relative to the currentTime
\begin{vdm_al}

public WaitRelative : nat ==> ()
WaitRelative(val) ==
  AddToWakeUpMap(threadid, currentTime + val);
 
\end{vdm_al}
WaitAbsolute: sleeps the calling thread undtil a specific time
\begin{vdm_al}
 
public WaitAbsolute : nat ==> ()
WaitAbsolute(val) ==
  AddToWakeUpMap(threadid, val);

\end{vdm_al}
AddToWakeUpMap: Utility operation - adding the thread to the wakeUpMap
\begin{vdm_al}

AddToWakeUpMap : nat * nat ==> ()
AddToWakeUpMap(tId, val) ==
   wakeUpMap := wakeUpMap ++ { tId |-> val };

\end{vdm_al}
NotifyThread: notified a specific thread - removing it from the wakeUpMap
\begin{vdm_al}

public NotifyThread : nat ==> ()
NotifyThread(tId) ==
 wakeUpMap := {tId} <-: wakeUpMap;

\end{vdm_al}
NotifyAll: notifies all threads - waking up threads which wakeUpTime is up 
\begin{vdm_al}

public NotifyAll : () ==> ()
NotifyAll() ==
  let threadSet : set of nat = {th | th in set dom wakeUpMap & wakeUpMap(th) <= currentTime }
  in
    for all t in set threadSet 
    do
      NotifyThread(t);

\end{vdm_al}
NotifyAndIncTime: Must only be used by ONE thread - usually the Environment thread.
Increments the currentTime with stepLength time units, and notifies all threads.
\begin{vdm_al}

public NotifyAndIncTime : () ==> ()
NotifyAndIncTime() ==
 (
        currentTime := currentTime + stepLength;
        NotifyAll();
--      syncWithTimeIncCurrent := syncWithTimeInc; 
 );

\end{vdm_al}
GetTime: Returns the currentTime.
\begin{vdm_al}

public GetTime : () ==> nat
GetTime() ==
  return currentTime;

\end{vdm_al}
Awake: Used to sleep threads - will not wake up until threadid is removed from wakeUpMap
\begin{vdm_al}

public Awake: () ==> ()
Awake() == skip;

\end{vdm_al}
SyncWithTimeIncrement: Called by threads which need to finish their loop/operation before time can be increased. 
YieldTimeIncrement is call when a thread is ready to a time increment. 
Once a thread has call SyncWithTimeIncrement is must call YieldTimeIncrement eventually, otherwise time increment 
will be prevented
\begin{vdm_al}

--public SyncWithTimeIncrement : () ==> ()
--SyncWithTimeIncrement() ==    
--(
--  syncWithTimeInc := syncWithTimeInc union {threadid}; --keep track of all
--  syncWithTimeIncCurrent := syncWithTimeIncCurrent union {threadid}; --include in current sync round
--  skip;
--);

--public YieldTimeIncrement: () ==> ()
--YieldTimeIncrement()==
--(
--  syncWithTimeIncCurrent := syncWithTimeIncCurrent \ {threadid};
--  skip
--);


sync
  per Awake => threadid not in set dom wakeUpMap;

  per NotifyAndIncTime => (card {th | th in set dom wakeUpMap & wakeUpMap(th) = currentTime +1} > 0) ;  --The magic one,  only allow run
--  per NotifyAndIncTime => ({th | th in set dom wakeUpMap & wakeUpMap(th) <= currentTime} inter syncWithTimeIncCurrent) = {};

  mutex(NotifyAll);
  mutex(AddToWakeUpMap);
  mutex(AddToWakeUpMap, NotifyAll); 
--  mutex(SyncWithTimeIncrement);
--  mutex(YieldTimeIncrement);
--  mutex(SyncWithTimeIncrement, YieldTimeIncrement, NotifyAndIncTime);

end TimeStamp
\end{vdm_al}

\begin{rtinfo}[TimeStamp`NotifyAndIncTime]
{vdm.tc}[TimeStamp]
\end{rtinfo}

class Types

types   
public Time = nat;
public Direction = <NORTH> | <SOUTH> | <EAST> | <WEST>;

public Event = BusRoute | Inflow | Simulate | WasteTime;

public BusRoute ::
        ID : nat
        route : seq of Road`RoadNumber
        t : Time;
        
public Inflow ::
        flow : nat
        t : Time; 
        
public Simulate ::
        t : nat;   
        
public WasteTime ::
        t : Time;
            
functions 
  public static DirectionToGraphics : Direction -> nat
  DirectionToGraphics(d) ==
  (
    cases d:
    <NORTH>-> 1,
    <SOUTH>-> 5,
    <EAST>->  3,
    <WEST>->  7
    end
  );
  
end Types

\begin{vdm_al}
class WaitNotify

instance variables

waitset : set of nat := {}

operations

public Wait : () ==> ()
Wait() ==
( AddToWaitSet (threadid);
  Awake()
);
    
public Notify : () ==> ()
Notify() ==
  let p in set waitset in
    waitset := waitset \ {p};

public NotifyThread: nat ==> ()
NotifyThread(tId) ==
  waitset :=  waitset \ {tId};

public NotifyAll: () ==> ()
NotifyAll() ==
  waitset :=  {};

private AddToWaitSet : nat ==> ()
AddToWaitSet(n) ==
  waitset := waitset union {n};

private Awake : () ==> ()
Awake() == skip

sync
per Awake => threadid not in set waitset;
mutex(AddToWaitSet)

end WaitNotify
\end{vdm_al}

\begin{rtinfo}[WaitNotify`AddToWaitSet]
{vdm.tc}[WaitNotify]
\end{rtinfo}

\begin{vdm_al}
class Waypoint

    types
        public BusStops = <A> | <B> | <C> | <D> | <E> | <F> | <Central>;
        public WaypointsEnum = <WP1> | <WP2> | <WP3> | <WP4> | BusStops;    

    instance variables
        protected id : WaypointsEnum;
        protected isStop : bool := false;

    operations
        public Waypoint : Waypoint`WaypointsEnum ==> Waypoint
        Waypoint(s) == 
        (
            id := s;
        );

        public GetId : () ==> WaypointsEnum
        GetId()== return id;

        public IsStop: () ==> bool
        IsStop()== return isStop;


end Waypoint

-----------------------------------------------
-- Class:           World
-- Description:     World class
-----------------------------------------------

-- Rules of this world
-- In the model, the city map is fixed and the buses and their route are defined in the inputvalues.txt
--
--       _ _ _ _ WP2_ _ _ _ _ C _ _ _ _ _ _ F _ _ _ _ _R8
--      |         |     R5    |     R7   R15|          |
--      |         |         R6|_ D _ _ _ _ _|WP4       | 
--      |R4       |R3            |    R11   |          |
--      |         |           R14|          |R10       |
--     A|_ _ _ _ B|_ _ _ _ _ _ _ WP1_ _R16_WP3_ _ _ _ _| Central 
--      |   R1           R2       |         |      R9  |
--      |                     R13 |_ _ E _ _|R12       |
--      |                                              |
--      |                                              |
--      |_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ | 
--                           HW1
--
-- ¤ Passengers arrive at a certain inflow rate on central station, their destination is randomly picked
-- ¤ Buses always drives at full speed according to the roads speed limit
-- ¤ Passengers will not get on buses that do not pass their stop
-- ¤ Passenger will not change between multiple buses to get to a stop
-- ¤ Buses always drives in cicles. i.e. the start and the stop of a route must be the same
-- ¤ A bus route is defined by roads, and the bus will stop at all stops it passes on these roads
-- ¤ The roads in the bus route must be connected end to end, as the bus can not jump passed pieces of road
-- ¤ Roads are connected by waypoints, some of these waypoints function as bus stops where passengers get off. 

class World

instance variables
public static graphics : gui_Graphics:= new gui_Graphics();

public static env : [Environment] := new Environment("inputvalues.txt");
public static timerRef : TimeStamp := new TimeStamp();  

operations

    public World: () ==> World
    World() ==
    (
        Printer`Out("World created: ");
        Printer`Out("------------------------------------------\n");
    );

    public Run: () ==> ()
    Run() == 
    (
        graphics.init();
        env.run();
        env.isFinished();

        env.report();

        Printer`Out("End of this world");
    );




end World


class IO

--  Overture STANDARD LIBRARY: INPUT/OUTPUT
--      --------------------------------------------
-- 
-- Standard library for the Overture Interpreter. When the interpreter
-- evaluates the preliminary functions/operations in this file,
-- corresponding internal functions is called instead of issuing a run
-- time error. Signatures should not be changed, as well as name of
-- module (VDM-SL) or class (VDM++). Pre/post conditions is 
-- fully user customizable. 
-- Don't care's may NOT be used in the parameter lists.
--
-- The in/out functions  will return false if an error occurs. In this
-- case an internal error string will be set (see 'ferror').
--
-- File path:
--  * An absolute path is accepted and used as specified.
--  * A relative path is relative to the debugger or if running in the 
--      Overture IDE relative to the project root.
--

types
 
/**
 * The file directive used in in/out functions.
 */
public filedirective = <start>|<append> 

functions

/**
 * Write VDM value in ASCII format to the console.
 *
 * @param val the VDM value to be written
 * @return true if successful else false
 */
public static writeval[@p]: @p -> bool
writeval(val)==
  is not yet specified;

/**
 * Write VDM value in ASCII format to file. The type of the val must be
 * specified as fwriteval[seq of char](...) when calling the function.
 *
 * @param filename the name of the file
 * @param val the VDM value to be written.
 * @param fdir if <start> then it will overwrite an existing file, 
 *  else <append> will append output to the existing file
 * @return true if successful else false
 */
public static fwriteval[@p]:seq1 of char * @p * filedirective -> bool
fwriteval(filename,val,fdir) ==
  is not yet specified;

/**
 * Read VDM value in ASCII format from file. The type which should be read must be
 * specified as freadval[seq of char](...) when calling the function.
 *
 * @param filename the name of the file
 * @return mk_(success,@p) if successful success will be 
 * set to true else false. @p will hold nil if unsuccessful or the value read.
 */
public static freadval[@p]:seq1 of char -> bool * [@p]
freadval(filename) ==
  is not yet specified
  post let mk_(b,t) = RESULT in not b => t = nil;

operations

/**
 * Write text to std out. Surrounding double quotes will be stripped,
 * backslashed characters should be interpreted.
 *
 * @param text the text to write to the console
 * @return if successful true else false.
 */
public echo: seq of char ==> bool
echo(text) ==
  fecho ("",text,nil);

/**
 * Write text to file like <code>echo</code>.
 *
 * @param filename the name of the file
 * @param text the text to write to be written.
 * @param fdir if nil or <start> then it will overwrite an existing file, 
 *  else <append> will append output to the existing file.
 * @return true if successful else false
 */
public fecho: seq of char * seq of char * [filedirective] ==> bool
fecho (filename,text,fdir) ==
  is not yet specified
  pre filename = "" <=> fdir = nil;

/**
 * Returns the last error which may have occurred by any of the io/out functions
 *
 * @return the last error message
 */
public ferror:()  ==> seq of char
ferror () ==
  is not yet specified;
  
-- New simplified format printing operations


/**
 * Prints any VDM value to the console
 *
 * @param arg a VDM value of any type
 */
public static print: ? ==> ()
print(arg) ==
    is not yet specified;

/**
 * Prints any VDM value to the console as a new line
 *
 * @param arg a VDM value of any type
 */
public static println: ? ==> ()
println(arg) ==
    is not yet specified;

/**
 * Prints any VDM value to the console
 *
 * @param format standard format string used in 
  *  Java by <code>String.format(format,value)</code>
 * @param arg a sequence of VDM values of any type
 */
public static printf: seq of char * seq of ? ==> ()
printf(format, args) ==
    is not yet specified;

end IO


class MATH

--  Overture STANDARD LIBRARY: MATH
--      --------------------------------------------
-- 
-- Standard library for the Overture Interpreter. When the interpreter
-- evaluates the preliminary functions/operations in this file,
-- corresponding internal functions is called instead of issuing a run
-- time error. Signatures should not be changed, as well as name of
-- module (VDM-SL) or class (VDM++). Pre/post conditions is 
-- fully user customisable. 
-- Dont care's may NOT be used in the parameter lists.

  functions
public static
    sin:real +> real
    sin(v) ==
    is not yet specified    
    post abs RESULT <= 1;

public static
    cos:real +> real
    cos(v) ==
    is not yet specified
    post abs RESULT <= 1;

public static
    tan:real -> real
    tan(a) ==
    is not yet specified
    pre cos(a) <> 0;

public static
    cot:real -> real    
    cot(a) ==
    is not yet specified -- Could also be: 1/tan(r)
    pre sin(a) <> 0;

public static
    asin:real -> real
    asin(a) ==
    is not yet specified
    pre abs a <= 1;

public static
    acos:real -> real
    acos(a) ==
    is not yet specified
    pre abs a <= 1;

public static
    atan:real +> real
    atan(v) ==
    is not yet specified;

public static
    acot:real +> real
    acot(a) ==
    atan(1/a)
    pre a <> 0;

public static
    sqrt:real -> real
    sqrt(a) ==
    is not yet specified
    pre a >= 0;

public static
    pi_f:() +> real
    pi_f () ==
    is not yet specified

  operations

public static
    srand:int ==> ()
    srand(a) ==
    let - = MATH`srand2(a) in skip
    pre a >= -1;

public static
    rand:int ==> int 
    rand(a) ==
    is not yet specified;

public static
    srand2:int ==> int 
    srand2(a) ==
    is not yet specified
    pre a >= -1

  functions

public static
    exp:real +> real
    exp(a) ==
    is not yet specified;

public static
    ln:real -> real
    ln(a) ==
    is not yet specified
    pre a > 0;

public static
    log:real -> real
    log(a) ==
    is not yet specified
    pre a > 0;

public static 
    fac:nat -> nat1 
    fac(a) == 
    is not yet specified 
    pre a < 21;         -- The limit for 64-bit calculations

  values
public
    pi = 3.14159265358979323846

 
end MATH


class VDMUtil

--  Overture STANDARD LIBRARY: MiscUtils
--      --------------------------------------------
-- 
-- Standard library for the Overture Interpreter. When the interpreter
-- evaluates the preliminary functions/operations in this file,
-- corresponding internal functions is called instead of issuing a run
-- time error. Signatures should not be changed, as well as name of
-- module (VDM-SL) or class (VDM++). Pre/post conditions is 
-- fully user customisable. 
-- Dont care's may NOT be used in the parameter lists.

functions
-- Converts a set argument into a sequence in non-deterministic order.
static public set2seq[@T] : set of @T +> seq of @T
set2seq(x) == is not yet specified;

-- Returns a context information tuple which represents
-- (fine_name * line_num * column_num * class_name * fnop_name) of corresponding source text
static public get_file_pos : () +> [ seq of char * nat * nat * seq of char * seq of char ]
get_file_pos() == is not yet specified;

-- Converts a VDM value into a seq of char.
static public val2seq_of_char[@T] : @T +> seq of char
val2seq_of_char(x) == is not yet specified;

-- converts VDM value in ASCII format into a VDM value
-- RESULT.#1 = false implies a conversion failure
static public seq_of_char2val[@p]:seq1 of char -> bool * [@p]
seq_of_char2val(s) ==
  is not yet specified
  post let mk_(b,t) = RESULT in not b => t = nil;

end VDMUtil

class Types

types   
public Time = nat;
public Direction = <NORTH> | <SOUTH> | <EAST> | <WEST>;

public Event = BusRoute | Inflow | Simulate | WasteTime;

public BusRoute ::
        ID : nat
        route : seq of Road`RoadNumber
        t : Time;
        
public Inflow ::
        flow : nat
        t : Time; 
        
public Simulate ::
        t : nat;   
        
public WasteTime ::
        t : Time;
            
functions 
  public static DirectionToGraphics : Direction -> nat
  DirectionToGraphics(d) ==
  (
    cases d:
    <NORTH>-> 1,
    <SOUTH>-> 5,
    <EAST>->  3,
    <WEST>->  7
    end
  );
  
end Types
