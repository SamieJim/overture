["non-empty sequence obligation in \u0027DEFAULT\u0027 (CMSL.vdmsl) at line 88:24: (forall missileInputs:DEFAULT`MissileInputs, outputSoFar:DEFAULT`Output, lastMissile:map (DEFAULT`MagId) to ([DEFAULT`MissileType]), curTime:nat \u0026 ((not (missileInputs \u003d [])) \u003d\u003e let mk_(curMis, angle):DEFAULT`MissileInput \u003d (hd missileInputs), magid:DEFAULT`MagId \u003d Angle2MagId(angle) in (((magid not in set (dom lastMissile)) or ((magid in set (dom lastMissile)) and (missilePriority(curMis) \u003e missilePriority(lastMissile(magid))))) \u003d\u003e let newOutput:DEFAULT`Output \u003d InterruptPlan(curTime, outputSoFar, responseDB(curMis), magid) in (missileInputs \u003c\u003e []))))","enumeration map injectivity obligation in \u0027DEFAULT\u0027 (CMSL.vdmsl) at line 44:25: (forall m1, m2 in set {{\u003cMissileA\u003e |-\u003e 1}, {\u003cMissileB\u003e |-\u003e 2}, {\u003cMissileC\u003e |-\u003e 3}, {\u003cNone\u003e |-\u003e 0}} \u0026 (forall d3 in set (dom m1), d4 in set (dom m2) \u0026 ((d3 \u003d d4) \u003d\u003e (m1(d3) \u003d m2(d4)))))","legal map application obligation in \u0027DEFAULT\u0027 (CMSL.vdmsl) at line 83:30: (forall missileInputs:DEFAULT`MissileInputs, outputSoFar:DEFAULT`Output, lastMissile:map (DEFAULT`MagId) to ([DEFAULT`MissileType]), curTime:nat \u0026 ((not (missileInputs \u003d [])) \u003d\u003e let mk_(curMis, angle):DEFAULT`MissileInput \u003d (hd missileInputs), magid:DEFAULT`MagId \u003d Angle2MagId(angle) in ((not (magid not in set (dom lastMissile))) \u003d\u003e ((magid in set (dom lastMissile)) \u003d\u003e (magid in set (dom lastMissile))))))","non-empty sequence obligation in \u0027DEFAULT\u0027 (CMSL.vdmsl) at line 137:44: (forall ts:seq of (DEFAULT`Response) \u0026 ((not (ts \u003d [])) \u003d\u003e (ts \u003c\u003e [])))","legal sequence application obligation in \u0027DEFAULT\u0027 (CMSL.vdmsl) at line 138:43: (forall ts:seq of (DEFAULT`Response) \u0026 ((not (ts \u003d [])) \u003d\u003e let mk_(f, t):DEFAULT`Response \u003d (hd ts), ns:seq of ((DEFAULT`FlareType * nat)) \u003d RelativeToAbsoluteTimes((tl ts)) in (forall i in set (inds ns) \u0026 (i in set (inds ns)))))","non-empty sequence obligation in \u0027DEFAULT\u0027 (CMSL.vdmsl) at line 91:21: (forall missileInputs:DEFAULT`MissileInputs, outputSoFar:DEFAULT`Output, lastMissile:map (DEFAULT`MagId) to ([DEFAULT`MissileType]), curTime:nat \u0026 ((not (missileInputs \u003d [])) \u003d\u003e let mk_(curMis, angle):DEFAULT`MissileInput \u003d (hd missileInputs), magid:DEFAULT`MagId \u003d Angle2MagId(angle) in ((not ((magid not in set (dom lastMissile)) or ((magid in set (dom lastMissile)) and (missilePriority(curMis) \u003e missilePriority(lastMissile(magid)))))) \u003d\u003e (missileInputs \u003c\u003e []))))","type compatibility obligation in \u0027DEFAULT\u0027 (CMSL.vdmsl) at line 61:30: (((inv_Angle(288) and inv_Angle(170)) and inv_Angle(222)) and inv_Angle(44))","non-empty sequence obligation in \u0027DEFAULT\u0027 (CMSL.vdmsl) at line 77:35: (forall missileInputs:DEFAULT`MissileInputs, outputSoFar:DEFAULT`Output, lastMissile:map (DEFAULT`MagId) to ([DEFAULT`MissileType]), curTime:nat \u0026 ((not (missileInputs \u003d [])) \u003d\u003e (missileInputs \u003c\u003e [])))","non-empty sequence obligation in \u0027DEFAULT\u0027 (CMSL.vdmsl) at line 125:32: (forall response:seq of (DEFAULT`Response) \u0026 let absTimes:seq of ((DEFAULT`FlareType * nat)) \u003d RelativeToAbsoluteTimes(response) in (absTimes \u003c\u003e []))","enumeration map injectivity obligation in \u0027DEFAULT\u0027 (CMSL.vdmsl) at line 36:5: (forall m1, m2 in set {{\u003cMissileA\u003e |-\u003e [mk_(\u003cFlareOneA\u003e, 900), mk_(\u003cFlareTwoA\u003e, 500), mk_(\u003cDoNothingA\u003e, 100), mk_(\u003cFlareOneA\u003e, 500)]}, {\u003cMissileB\u003e |-\u003e [mk_(\u003cFlareTwoB\u003e, 500), mk_(\u003cFlareTwoB\u003e, 700)]}, {\u003cMissileC\u003e |-\u003e [mk_(\u003cFlareOneC\u003e, 400), mk_(\u003cDoNothingC\u003e, 100), mk_(\u003cFlareTwoC\u003e, 400), mk_(\u003cFlareOneC\u003e, 500)]}} \u0026 (forall d3 in set (dom m1), d4 in set (dom m2) \u0026 ((d3 \u003d d4) \u003d\u003e (m1(d3) \u003d m2(d4)))))","non-empty sequence obligation in \u0027DEFAULT\u0027 (CMSL.vdmsl) at line 136:26: (forall ts:seq of (DEFAULT`Response) \u0026 ((not (ts \u003d [])) \u003d\u003e (ts \u003c\u003e [])))","recursive function obligation in \u0027DEFAULT\u0027 (CMSL.vdmsl) at line 88:18: (forall missileInputs:DEFAULT`MissileInputs, outputSoFar:DEFAULT`Output, lastMissile:map (DEFAULT`MagId) to ([DEFAULT`MissileType]), curTime:nat \u0026 ((not (missileInputs \u003d [])) \u003d\u003e let mk_(curMis, angle):DEFAULT`MissileInput \u003d (hd missileInputs), magid:DEFAULT`MagId \u003d Angle2MagId(angle) in (((magid not in set (dom lastMissile)) or ((magid in set (dom lastMissile)) and (missilePriority(curMis) \u003e missilePriority(lastMissile(magid))))) \u003d\u003e let newOutput:DEFAULT`Output \u003d InterruptPlan(curTime, outputSoFar, responseDB(curMis), magid) in (CMLen(missileInputs, outputSoFar, lastMissile, curTime) \u003e CMLen((tl missileInputs), newOutput, (lastMissile ++ {magid |-\u003e curMis}), (curTime + stepLength))))))","type compatibility obligation in \u0027DEFAULT\u0027 (CMSL.vdmsl) at line 56:30: (((inv_Angle(188) and inv_Angle(70)) and inv_Angle(2)) and inv_Angle(44))","legal sequence application obligation in \u0027DEFAULT\u0027 (CMSL.vdmsl) at line 111:4: (forall output_l:seq of (DEFAULT`OutputStep), curTime:nat \u0026 (forall i in set (inds output_l) \u0026 (let mk_(-, t):DEFAULT`OutputStep \u003d output_l(i) in (t \u003c\u003d curTime) \u003d\u003e (i in set (inds output_l)))))","map compatible obligation in \u0027DEFAULT\u0027 (CMSL.vdmsl) at line 100:3: (forall curTime:nat, expOutput:DEFAULT`Output, plan:DEFAULT`Plan, magid:DEFAULT`MagId \u0026 (forall ldom1 in set (dom {magid |-\u003e ((if (magid in set (dom expOutput))\nthen LeavePrefixUnchanged(expOutput(magid), curTime)\nelse []) ^ MakeOutputFromPlan(curTime, plan))}), rdom2 in set (dom ({magid} \u003c-: expOutput)) \u0026 ((ldom1 \u003d rdom2) \u003d\u003e ({magid |-\u003e ((if (magid in set (dom expOutput))\nthen LeavePrefixUnchanged(expOutput(magid), curTime)\nelse []) ^ MakeOutputFromPlan(curTime, plan))}(ldom1) \u003d ({magid} \u003c-: expOutput)(rdom2)))))","legal sequence application obligation in \u0027DEFAULT\u0027 (CMSL.vdmsl) at line 112:33: (forall output_l:seq of (DEFAULT`OutputStep), curTime:nat \u0026 (forall i in set (inds output_l) \u0026 (i in set (inds output_l))))","legal map application obligation in \u0027DEFAULT\u0027 (CMSL.vdmsl) at line 82:14: (forall missileInputs:DEFAULT`MissileInputs, outputSoFar:DEFAULT`Output, lastMissile:map (DEFAULT`MagId) to ([DEFAULT`MissileType]), curTime:nat \u0026 ((not (missileInputs \u003d [])) \u003d\u003e let mk_(curMis, angle):DEFAULT`MissileInput \u003d (hd missileInputs), magid:DEFAULT`MagId \u003d Angle2MagId(angle) in ((not (magid not in set (dom lastMissile))) \u003d\u003e ((magid in set (dom lastMissile)) \u003d\u003e (curMis in set (dom missilePriority))))))","legal map application obligation in \u0027DEFAULT\u0027 (CMSL.vdmsl) at line 83:14: (forall missileInputs:DEFAULT`MissileInputs, outputSoFar:DEFAULT`Output, lastMissile:map (DEFAULT`MagId) to ([DEFAULT`MissileType]), curTime:nat \u0026 ((not (missileInputs \u003d [])) \u003d\u003e let mk_(curMis, angle):DEFAULT`MissileInput \u003d (hd missileInputs), magid:DEFAULT`MagId \u003d Angle2MagId(angle) in ((not (magid not in set (dom lastMissile))) \u003d\u003e ((magid in set (dom lastMissile)) \u003d\u003e (lastMissile(magid) in set (dom missilePriority))))))","type compatibility obligation in \u0027DEFAULT\u0027 (CMSL.vdmsl) at line 83:30: (forall missileInputs:DEFAULT`MissileInputs, outputSoFar:DEFAULT`Output, lastMissile:map (DEFAULT`MagId) to ([DEFAULT`MissileType]), curTime:nat \u0026 ((not (missileInputs \u003d [])) \u003d\u003e let mk_(curMis, angle):DEFAULT`MissileInput \u003d (hd missileInputs), magid:DEFAULT`MagId \u003d Angle2MagId(angle) in ((not (magid not in set (dom lastMissile))) \u003d\u003e ((magid in set (dom lastMissile)) \u003d\u003e (((is_(lastMissile(magid), \u003cMissileA\u003e) or is_(lastMissile(magid), \u003cMissileB\u003e)) or is_(lastMissile(magid), \u003cMissileC\u003e)) or is_(lastMissile(magid), \u003cNone\u003e))))))","legal map application obligation in \u0027DEFAULT\u0027 (CMSL.vdmsl) at line 86:36: (forall missileInputs:DEFAULT`MissileInputs, outputSoFar:DEFAULT`Output, lastMissile:map (DEFAULT`MagId) to ([DEFAULT`MissileType]), curTime:nat \u0026 ((not (missileInputs \u003d [])) \u003d\u003e let mk_(curMis, angle):DEFAULT`MissileInput \u003d (hd missileInputs), magid:DEFAULT`MagId \u003d Angle2MagId(angle) in (((magid not in set (dom lastMissile)) or ((magid in set (dom lastMissile)) and (missilePriority(curMis) \u003e missilePriority(lastMissile(magid))))) \u003d\u003e (curMis in set (dom responseDB)))))","recursive function obligation in \u0027DEFAULT\u0027 (CMSL.vdmsl) at line 91:15: (forall missileInputs:DEFAULT`MissileInputs, outputSoFar:DEFAULT`Output, lastMissile:map (DEFAULT`MagId) to ([DEFAULT`MissileType]), curTime:nat \u0026 ((not (missileInputs \u003d [])) \u003d\u003e let mk_(curMis, angle):DEFAULT`MissileInput \u003d (hd missileInputs), magid:DEFAULT`MagId \u003d Angle2MagId(angle) in ((not ((magid not in set (dom lastMissile)) or ((magid in set (dom lastMissile)) and (missilePriority(curMis) \u003e missilePriority(lastMissile(magid)))))) \u003d\u003e (CMLen(missileInputs, outputSoFar, lastMissile, curTime) \u003e CMLen((tl missileInputs), outputSoFar, lastMissile, (curTime + stepLength))))))","type compatibility obligation in \u0027DEFAULT\u0027 (CMSL.vdmsl) at line 51:30: (((inv_Angle(88) and inv_Angle(70)) and inv_Angle(222)) and inv_Angle(44))","legal map application obligation in \u0027DEFAULT\u0027 (CMSL.vdmsl) at line 101:41: (forall curTime:nat, expOutput:DEFAULT`Output, plan:DEFAULT`Plan, magid:DEFAULT`MagId \u0026 ((magid in set (dom expOutput)) \u003d\u003e (magid in set (dom expOutput))))","legal sequence application obligation in \u0027DEFAULT\u0027 (CMSL.vdmsl) at line 117:25: (forall curTime:nat, response:seq of (DEFAULT`Response) \u0026 let output:seq of (DEFAULT`OutputStep) \u003d OutputAtTimeZero(response) in (forall i in set (inds output) \u0026 (i in set (inds output))))","type invariant satisfiable obligation in \u0027DEFAULT\u0027 (CMSL.vdmsl) at line 12:3: (exists num:DEFAULT`Angle \u0026 (num \u003c\u003d 360))","legal sequence application obligation in \u0027DEFAULT\u0027 (CMSL.vdmsl) at line 128:24: (forall response:seq of (DEFAULT`Response) \u0026 let absTimes:seq of ((DEFAULT`FlareType * nat)) \u003d RelativeToAbsoluteTimes(response) in let mk_(firstFlare, -):(DEFAULT`FlareType * nat) \u003d (hd absTimes) in (forall i in set {2, ... ,(len absTimes)} \u0026 (i in set (inds absTimes))))","recursive function obligation in \u0027DEFAULT\u0027 (CMSL.vdmsl) at line 137:17: (forall ts:seq of (DEFAULT`Response) \u0026 ((not (ts \u003d [])) \u003d\u003e (RespLen(ts) \u003e RespLen((tl ts)))))","legal sequence application obligation in \u0027DEFAULT\u0027 (CMSL.vdmsl) at line 127:24: (forall response:seq of (DEFAULT`Response) \u0026 let absTimes:seq of ((DEFAULT`FlareType * nat)) \u003d RelativeToAbsoluteTimes(response) in let mk_(firstFlare, -):(DEFAULT`FlareType * nat) \u003d (hd absTimes) in (forall i in set {2, ... ,(len absTimes)} \u0026 ((i - 1) in set (inds absTimes))))"]