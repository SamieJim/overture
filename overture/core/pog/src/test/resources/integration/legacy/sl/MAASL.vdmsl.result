["legal function application obligation in \u0027DEFAULT\u0027 (MAASL.vdmsl) at line 213:14: (forall K:DEFAULT`Double_Number \u0026 let X:DEFAULT`Number \u003d (hd K), Y:DEFAULT`Number \u003d (hd (tl K)) in let X\u0027:seq1 of (DEFAULT`Number) \u003d [Byte(X, 3), Byte(X, 2), Byte(X, 1), Byte(X, 0)], Y\u0027:seq1 of (DEFAULT`Number) \u003d [Byte(Y, 3), Byte(Y, 2), Byte(Y, 1), Byte(X, 0)] in let XY:seq1 of (DEFAULT`Number) \u003d (X\u0027 ^ Y\u0027), P:nat \u003d 0 in let XY\u0027:DEFAULT`Message_in_blocks \u003d Condition_Sequence(XY, P) in pre_Get_head_in_blocks(XY\u0027, 4))","non-empty sequence obligation in \u0027DEFAULT\u0027 (MAASL.vdmsl) at line 268:29: (forall M:DEFAULT`Message_in_blocks, P:DEFAULT`Number \u0026 ((not ((len M) \u003d 1)) \u003d\u003e (M \u003c\u003e [])))","type compatibility obligation in \u0027DEFAULT\u0027 (MAASL.vdmsl) at line 89:4: (forall M:DEFAULT`Message_in_bits \u0026 inv_Message_in_bits(let No_Extra_bits:int \u003d (Word_Length - ((len M) mod Word_Length)) in (if (No_Extra_bits \u003d Word_Length)\nthen M\nelse (M ^ Get_Application_defined_bits(M, No_Extra_bits)))))","non-empty sequence obligation in \u0027DEFAULT\u0027 (MAASL.vdmsl) at line 338:18: (forall M:DEFAULT`Message_in_blocks_plus_empty_Message, KC:DEFAULT`Key_Constant \u0026 let mk_Key_Constant(X, Y, V, W, S, T):DEFAULT`Key_Constant \u003d KC in ((not ((len M) \u003d 0)) \u003d\u003e let Mi:DEFAULT`Number \u003d (hd M) in let V\u0027:DEFAULT`Number \u003d CYC(V) in let E:DEFAULT`Number \u003d XOR(V\u0027, W), X\u0027:DEFAULT`Number \u003d XOR(X, Mi), Y\u0027:DEFAULT`Number \u003d XOR(Y, Mi) in let F:DEFAULT`Number \u003d ADD(E, Y\u0027), G:DEFAULT`Number \u003d ADD(E, X\u0027) in let F\u0027:DEFAULT`Number \u003d OR(F, A), G\u0027:DEFAULT`Number \u003d OR(G, B) in let F\u0027\u0027:DEFAULT`Number \u003d AND(F\u0027, C), G\u0027\u0027:DEFAULT`Number \u003d AND(G\u0027, D) in let X\u0027\u0027:DEFAULT`Number \u003d MUL1(X\u0027, F\u0027\u0027), Y\u0027\u0027:DEFAULT`Number \u003d MUL2A(Y\u0027, G\u0027\u0027) in (M \u003c\u003e [])))","non-empty sequence obligation in \u0027DEFAULT\u0027 (MAASL.vdmsl) at line 409:45: (forall M:DEFAULT`Message_in_blocks, No_blocks:nat \u0026 ((((len M) \u003e\u003d No_blocks) and (No_blocks \u003e\u003d 1)) \u003d\u003e ((not (No_blocks \u003d 0)) \u003d\u003e (M \u003c\u003e []))))","type compatibility obligation in \u0027DEFAULT\u0027 (MAASL.vdmsl) at line 180:58: (forall X:DEFAULT`Number, Y:DEFAULT`Number \u0026 let L:int \u003d ((X * Y) mod Maximum_Number_Size_plus_1), U:int \u003d ((X * Y) div Maximum_Number_Size_plus_1) in let D:DEFAULT`Number \u003d ADD(U, U), E:DEFAULT`Number \u003d CAR(U, U) in let F:DEFAULT`Number \u003d ADD(D, (2 * E)) in (inv_Number(L) and is_(L, nat)))","type compatibility obligation in \u0027DEFAULT\u0027 (MAASL.vdmsl) at line 193:16: (forall X:DEFAULT`Number, Y:DEFAULT`Number \u0026 ((((X div Maximum_Number_Size_plus_1_div_2) \u003d 0) or ((Y div Maximum_Number_Size_plus_1_div_2) \u003d 0)) \u003d\u003e let L:int \u003d ((X * Y) mod Maximum_Number_Size_plus_1), U:int \u003d ((X * Y) div Maximum_Number_Size_plus_1) in (inv_Number(U) and is_(U, nat))))","legal function application obligation in \u0027DEFAULT\u0027 (MAASL.vdmsl) at line 388:10: (forall M:DEFAULT`Message_in_bits, No_bits:nat \u0026 (((len M) \u003e\u003d No_bits) \u003d\u003e ((not (No_bits \u003d 0)) \u003d\u003e pre_Get_tail_in_bits((tl M), (No_bits - 1)))))","legal function application obligation in \u0027DEFAULT\u0027 (MAASL.vdmsl) at line 258:34: (forall D:DEFAULT`Double_Number \u0026 let X:DEFAULT`Number \u003d (hd D), Y:DEFAULT`Number \u003d (hd (tl D)) in pre_Byte(Y, 1))","type compatibility obligation in \u0027DEFAULT\u0027 (MAASL.vdmsl) at line 376:17: (forall M:DEFAULT`Message_in_blocks, K:DEFAULT`Key, No_blocks:nat \u0026 ((not ((len M) \u003c\u003d No_blocks)) \u003d\u003e let M\u0027:seq1 of (DEFAULT`Number) \u003d ([Z(Get_head_in_blocks(M, No_blocks), K)] ^ Get_tail_in_blocks(M, No_blocks)) in (inv_Message_in_blocks(M\u0027) and inv_Message_in_blocks_plus_empty_Message(M\u0027))))","non-empty sequence obligation in \u0027DEFAULT\u0027 (MAASL.vdmsl) at line 281:18: (forall K:DEFAULT`Key \u0026 let J1K1:DEFAULT`Double_Number \u003d BYT(K) in ((tl J1K1) \u003c\u003e []))","type compatibility obligation in \u0027DEFAULT\u0027 (MAASL.vdmsl) at line 168:16: (forall X:DEFAULT`Number, Y:DEFAULT`Number \u0026 let L:int \u003d ((X * Y) mod Maximum_Number_Size_plus_1), U:int \u003d ((X * Y) div Maximum_Number_Size_plus_1) in (inv_Number(U) and is_(U, nat)))","non-empty sequence obligation in \u0027DEFAULT\u0027 (MAASL.vdmsl) at line 312:37: (forall K:DEFAULT`Key \u0026 let J1K1:DEFAULT`Double_Number \u003d BYT(K) in let J1:DEFAULT`Number \u003d (hd J1K1), K1:DEFAULT`Number \u003d (hd (tl J1K1)), P:DEFAULT`Number \u003d PAT(K), Q:nat1 \u003d ((1 + P) * (1 + P)) in let J12:DEFAULT`Number \u003d MUL1(J1, J1), J22:DEFAULT`Number \u003d MUL2(J1, J1) in let J14:DEFAULT`Number \u003d MUL1(J12, J12), J24:DEFAULT`Number \u003d MUL2(J22, J22) in let J16:DEFAULT`Number \u003d MUL1(J12, J14), J26:DEFAULT`Number \u003d MUL2(J22, J24) in let J18:DEFAULT`Number \u003d MUL1(J12, J16), J28:DEFAULT`Number \u003d MUL2(J22, J26) in let H4:DEFAULT`Number \u003d XOR(J14, J28), H6:DEFAULT`Number \u003d XOR(J16, J26), H8:DEFAULT`Number \u003d XOR(J18, J28) in let K12:DEFAULT`Number \u003d MUL1(K1, K1), K22:DEFAULT`Number \u003d MUL2(K1, K1) in let K14:DEFAULT`Number \u003d MUL1(K12, K12), K24:DEFAULT`Number \u003d MUL2(K22, K22) in let K15:DEFAULT`Number \u003d MUL1(K1, K14), K25:DEFAULT`Number \u003d MUL2(K1, K24) in let K17:DEFAULT`Number \u003d MUL1(K12, K15), K27:DEFAULT`Number \u003d MUL2(K22, K25) in let K19:DEFAULT`Number \u003d MUL1(K12, K17), K29:DEFAULT`Number \u003d MUL2(K22, K27) in let H\u0027:DEFAULT`Number \u003d XOR(K15, K25) in let H5:DEFAULT`Number \u003d MUL2(H\u0027, Q), H7:DEFAULT`Number \u003d XOR(K17, K27), H9:DEFAULT`Number \u003d XOR(K19, K29) in let X0Y0:DEFAULT`Double_Number \u003d BYT([H4, H5]), V0W:DEFAULT`Double_Number \u003d BYT([H6, H7]), ST:DEFAULT`Double_Number \u003d BYT([H8, H9]) in (X0Y0 \u003c\u003e []))","type compatibility obligation in \u0027DEFAULT\u0027 (MAASL.vdmsl) at line 180:14: (forall X:DEFAULT`Number, Y:DEFAULT`Number \u0026 let L:int \u003d ((X * Y) mod Maximum_Number_Size_plus_1), U:int \u003d ((X * Y) div Maximum_Number_Size_plus_1) in (inv_Number(U) and is_(U, nat)))","non-empty sequence obligation in \u0027DEFAULT\u0027 (MAASL.vdmsl) at line 312:24: (forall K:DEFAULT`Key \u0026 let J1K1:DEFAULT`Double_Number \u003d BYT(K) in let J1:DEFAULT`Number \u003d (hd J1K1), K1:DEFAULT`Number \u003d (hd (tl J1K1)), P:DEFAULT`Number \u003d PAT(K), Q:nat1 \u003d ((1 + P) * (1 + P)) in let J12:DEFAULT`Number \u003d MUL1(J1, J1), J22:DEFAULT`Number \u003d MUL2(J1, J1) in let J14:DEFAULT`Number \u003d MUL1(J12, J12), J24:DEFAULT`Number \u003d MUL2(J22, J22) in let J16:DEFAULT`Number \u003d MUL1(J12, J14), J26:DEFAULT`Number \u003d MUL2(J22, J24) in let J18:DEFAULT`Number \u003d MUL1(J12, J16), J28:DEFAULT`Number \u003d MUL2(J22, J26) in let H4:DEFAULT`Number \u003d XOR(J14, J28), H6:DEFAULT`Number \u003d XOR(J16, J26), H8:DEFAULT`Number \u003d XOR(J18, J28) in let K12:DEFAULT`Number \u003d MUL1(K1, K1), K22:DEFAULT`Number \u003d MUL2(K1, K1) in let K14:DEFAULT`Number \u003d MUL1(K12, K12), K24:DEFAULT`Number \u003d MUL2(K22, K22) in let K15:DEFAULT`Number \u003d MUL1(K1, K14), K25:DEFAULT`Number \u003d MUL2(K1, K24) in let K17:DEFAULT`Number \u003d MUL1(K12, K15), K27:DEFAULT`Number \u003d MUL2(K22, K25) in let K19:DEFAULT`Number \u003d MUL1(K12, K17), K29:DEFAULT`Number \u003d MUL2(K22, K27) in let H\u0027:DEFAULT`Number \u003d XOR(K15, K25) in let H5:DEFAULT`Number \u003d MUL2(H\u0027, Q), H7:DEFAULT`Number \u003d XOR(K17, K27), H9:DEFAULT`Number \u003d XOR(K19, K29) in let X0Y0:DEFAULT`Double_Number \u003d BYT([H4, H5]), V0W:DEFAULT`Double_Number \u003d BYT([H6, H7]), ST:DEFAULT`Double_Number \u003d BYT([H8, H9]) in (X0Y0 \u003c\u003e []))","legal function application obligation in \u0027DEFAULT\u0027 (MAASL.vdmsl) at line 208:44: (forall K:DEFAULT`Double_Number \u0026 let X:DEFAULT`Number \u003d (hd K), Y:DEFAULT`Number \u003d (hd (tl K)) in pre_Byte(X, 0))","legal function application obligation in \u0027DEFAULT\u0027 (MAASL.vdmsl) at line 106:35: (forall M:DEFAULT`Message_in_bits \u0026 ((((len M) \u003e\u003d Word_Length) and (((len M) mod Word_Length) \u003d 0)) \u003d\u003e ((not ((len M) \u003d Word_Length)) \u003d\u003e pre_Get_tail_in_bits(M, Word_Length))))","non-empty sequence obligation in \u0027DEFAULT\u0027 (MAASL.vdmsl) at line 206:16: (forall K:DEFAULT`Double_Number \u0026 (K \u003c\u003e []))","non-empty sequence obligation in \u0027DEFAULT\u0027 (MAASL.vdmsl) at line 252:47: (forall M:DEFAULT`Message_in_blocks \u0026 ((not ((len M) \u003d 1)) \u003d\u003e (M \u003c\u003e [])))","non-empty sequence obligation in \u0027DEFAULT\u0027 (MAASL.vdmsl) at line 312:46: (forall K:DEFAULT`Key \u0026 let J1K1:DEFAULT`Double_Number \u003d BYT(K) in let J1:DEFAULT`Number \u003d (hd J1K1), K1:DEFAULT`Number \u003d (hd (tl J1K1)), P:DEFAULT`Number \u003d PAT(K), Q:nat1 \u003d ((1 + P) * (1 + P)) in let J12:DEFAULT`Number \u003d MUL1(J1, J1), J22:DEFAULT`Number \u003d MUL2(J1, J1) in let J14:DEFAULT`Number \u003d MUL1(J12, J12), J24:DEFAULT`Number \u003d MUL2(J22, J22) in let J16:DEFAULT`Number \u003d MUL1(J12, J14), J26:DEFAULT`Number \u003d MUL2(J22, J24) in let J18:DEFAULT`Number \u003d MUL1(J12, J16), J28:DEFAULT`Number \u003d MUL2(J22, J26) in let H4:DEFAULT`Number \u003d XOR(J14, J28), H6:DEFAULT`Number \u003d XOR(J16, J26), H8:DEFAULT`Number \u003d XOR(J18, J28) in let K12:DEFAULT`Number \u003d MUL1(K1, K1), K22:DEFAULT`Number \u003d MUL2(K1, K1) in let K14:DEFAULT`Number \u003d MUL1(K12, K12), K24:DEFAULT`Number \u003d MUL2(K22, K22) in let K15:DEFAULT`Number \u003d MUL1(K1, K14), K25:DEFAULT`Number \u003d MUL2(K1, K24) in let K17:DEFAULT`Number \u003d MUL1(K12, K15), K27:DEFAULT`Number \u003d MUL2(K22, K25) in let K19:DEFAULT`Number \u003d MUL1(K12, K17), K29:DEFAULT`Number \u003d MUL2(K22, K27) in let H\u0027:DEFAULT`Number \u003d XOR(K15, K25) in let H5:DEFAULT`Number \u003d MUL2(H\u0027, Q), H7:DEFAULT`Number \u003d XOR(K17, K27), H9:DEFAULT`Number \u003d XOR(K19, K29) in let X0Y0:DEFAULT`Double_Number \u003d BYT([H4, H5]), V0W:DEFAULT`Double_Number \u003d BYT([H6, H7]), ST:DEFAULT`Double_Number \u003d BYT([H8, H9]) in (V0W \u003c\u003e []))","type compatibility obligation in \u0027DEFAULT\u0027 (MAASL.vdmsl) at line 154:4: (forall X:DEFAULT`Number, Y:DEFAULT`Number \u0026 (inv_Number(((X + Y) div Maximum_Number_Size_plus_1)) and is_(((X + Y) div Maximum_Number_Size_plus_1), nat)))","type compatibility obligation in \u0027DEFAULT\u0027 (MAASL.vdmsl) at line 231:4: (forall B:DEFAULT`Number, P:DEFAULT`Number \u0026 (inv_Number(let P\u0027:nat \u003d (2 * P) in let P\u0027\u0027:nat1 \u003d (P\u0027 + 1) in (if (B \u003d 0)\nthen P\u0027\u0027\nelse (if (B \u003d ((2 ** 8) - 1))\nthen (((2 ** 8) - 1) - P\u0027\u0027)\nelse B))) and is_(let P\u0027:nat \u003d (2 * P) in let P\u0027\u0027:nat1 \u003d (P\u0027 + 1) in (if (B \u003d 0)\nthen P\u0027\u0027\nelse (if (B \u003d ((2 ** 8) - 1))\nthen (((2 ** 8) - 1) - P\u0027\u0027)\nelse B)), nat)))","type compatibility obligation in \u0027DEFAULT\u0027 (MAASL.vdmsl) at line 180:12: (forall X:DEFAULT`Number, Y:DEFAULT`Number \u0026 let L:int \u003d ((X * Y) mod Maximum_Number_Size_plus_1), U:int \u003d ((X * Y) div Maximum_Number_Size_plus_1) in (inv_Number(U) and is_(U, nat)))","legal function application obligation in \u0027DEFAULT\u0027 (MAASL.vdmsl) at line 258:44: (forall D:DEFAULT`Double_Number \u0026 let X:DEFAULT`Number \u003d (hd D), Y:DEFAULT`Number \u003d (hd (tl D)) in pre_Byte(Y, 0))","type compatibility obligation in \u0027DEFAULT\u0027 (MAASL.vdmsl) at line 368:17: (forall M:DEFAULT`Message_in_bits, K:DEFAULT`Key \u0026 let M\u0027:DEFAULT`Message_in_bits \u003d Pad_out_Message(M) in let M\u0027\u0027:DEFAULT`Message_in_blocks \u003d Form_Message_into_blocks(M\u0027) in ((not ((len M\u0027\u0027) \u003c\u003d Maximum_No_of_blocks_for_MAC)) \u003d\u003e let M\u0027\u0027\u0027:seq1 of (DEFAULT`Number) \u003d ([Z(Get_head_in_blocks(M\u0027\u0027, Maximum_No_of_blocks_for_MAC), K)] ^ Get_tail_in_blocks(M\u0027\u0027, Maximum_No_of_blocks_for_MAC)) in (inv_Message_in_blocks(M\u0027\u0027\u0027) and inv_Message_in_blocks_plus_empty_Message(M\u0027\u0027\u0027))))","legal function application obligation in \u0027DEFAULT\u0027 (MAASL.vdmsl) at line 259:14: (forall D:DEFAULT`Double_Number \u0026 let X:DEFAULT`Number \u003d (hd D), Y:DEFAULT`Number \u003d (hd (tl D)) in pre_Byte(Y, 3))","type compatibility obligation in \u0027DEFAULT\u0027 (MAASL.vdmsl) at line 179:60: (forall X:DEFAULT`Number, Y:DEFAULT`Number \u0026 let L:int \u003d ((X * Y) mod Maximum_Number_Size_plus_1), U:int \u003d ((X * Y) div Maximum_Number_Size_plus_1) in (inv_Number(U) and is_(U, nat)))","non-empty sequence obligation in \u0027DEFAULT\u0027 (MAASL.vdmsl) at line 112:14: (forall M:DEFAULT`Message_in_bits \u0026 (((len M) \u003c\u003d Word_Length) \u003d\u003e ((not ((len M) \u003d 1)) \u003d\u003e (M \u003c\u003e []))))","type compatibility obligation in \u0027DEFAULT\u0027 (MAASL.vdmsl) at line 179:62: (forall X:DEFAULT`Number, Y:DEFAULT`Number \u0026 let L:int \u003d ((X * Y) mod Maximum_Number_Size_plus_1), U:int \u003d ((X * Y) div Maximum_Number_Size_plus_1) in (inv_Number(U) and is_(U, nat)))","non-empty sequence obligation in \u0027DEFAULT\u0027 (MAASL.vdmsl) at line 394:15: (forall M:DEFAULT`Message_in_bits, No_bits:nat \u0026 ((((len M) \u003e\u003d No_bits) and (No_bits \u003e\u003d 1)) \u003d\u003e ((No_bits \u003d 0) \u003d\u003e (M \u003c\u003e []))))","non-empty sequence obligation in \u0027DEFAULT\u0027 (MAASL.vdmsl) at line 312:74: (forall K:DEFAULT`Key \u0026 let J1K1:DEFAULT`Double_Number \u003d BYT(K) in let J1:DEFAULT`Number \u003d (hd J1K1), K1:DEFAULT`Number \u003d (hd (tl J1K1)), P:DEFAULT`Number \u003d PAT(K), Q:nat1 \u003d ((1 + P) * (1 + P)) in let J12:DEFAULT`Number \u003d MUL1(J1, J1), J22:DEFAULT`Number \u003d MUL2(J1, J1) in let J14:DEFAULT`Number \u003d MUL1(J12, J12), J24:DEFAULT`Number \u003d MUL2(J22, J22) in let J16:DEFAULT`Number \u003d MUL1(J12, J14), J26:DEFAULT`Number \u003d MUL2(J22, J24) in let J18:DEFAULT`Number \u003d MUL1(J12, J16), J28:DEFAULT`Number \u003d MUL2(J22, J26) in let H4:DEFAULT`Number \u003d XOR(J14, J28), H6:DEFAULT`Number \u003d XOR(J16, J26), H8:DEFAULT`Number \u003d XOR(J18, J28) in let K12:DEFAULT`Number \u003d MUL1(K1, K1), K22:DEFAULT`Number \u003d MUL2(K1, K1) in let K14:DEFAULT`Number \u003d MUL1(K12, K12), K24:DEFAULT`Number \u003d MUL2(K22, K22) in let K15:DEFAULT`Number \u003d MUL1(K1, K14), K25:DEFAULT`Number \u003d MUL2(K1, K24) in let K17:DEFAULT`Number \u003d MUL1(K12, K15), K27:DEFAULT`Number \u003d MUL2(K22, K25) in let K19:DEFAULT`Number \u003d MUL1(K12, K17), K29:DEFAULT`Number \u003d MUL2(K22, K27) in let H\u0027:DEFAULT`Number \u003d XOR(K15, K25) in let H5:DEFAULT`Number \u003d MUL2(H\u0027, Q), H7:DEFAULT`Number \u003d XOR(K17, K27), H9:DEFAULT`Number \u003d XOR(K19, K29) in let X0Y0:DEFAULT`Double_Number \u003d BYT([H4, H5]), V0W:DEFAULT`Double_Number \u003d BYT([H6, H7]), ST:DEFAULT`Double_Number \u003d BYT([H8, H9]) in ((tl ST) \u003c\u003e []))","type invariant satisfiable obligation in \u0027DEFAULT\u0027 (MAASL.vdmsl) at line 40:4: (exists N:DEFAULT`Number \u0026 (N \u003c Maximum_Number_Size_plus_1))","type compatibility obligation in \u0027DEFAULT\u0027 (MAASL.vdmsl) at line 94:47: (forall M:DEFAULT`Message_in_bits \u0026 let No_Extra_bits:int \u003d (Word_Length - ((len M) mod Word_Length)) in ((not (No_Extra_bits \u003d Word_Length)) \u003d\u003e (No_Extra_bits \u003e\u003d 0)))","type compatibility obligation in \u0027DEFAULT\u0027 (MAASL.vdmsl) at line 101:4: (forall M:DEFAULT`Message_in_bits \u0026 ((((len M) \u003e\u003d Word_Length) and (((len M) mod Word_Length) \u003d 0)) \u003d\u003e (inv_Message_in_blocks((if ((len M) \u003d Word_Length)\nthen [Form_Number(M)]\nelse ([Form_Number(Get_head_in_bits(M, Word_Length))] ^ Form_Message_into_blocks(Get_tail_in_bits(M, Word_Length))))) and inv_Message_in_blocks_plus_empty_Message((if ((len M) \u003d Word_Length)\nthen [Form_Number(M)]\nelse ([Form_Number(Get_head_in_bits(M, Word_Length))] ^ Form_Message_into_blocks(Get_tail_in_bits(M, Word_Length))))))))","type compatibility obligation in \u0027DEFAULT\u0027 (MAASL.vdmsl) at line 367:44: (forall M:DEFAULT`Message_in_bits, K:DEFAULT`Key \u0026 let M\u0027:DEFAULT`Message_in_bits \u003d Pad_out_Message(M) in let M\u0027\u0027:DEFAULT`Message_in_blocks \u003d Form_Message_into_blocks(M\u0027) in ((not ((len M\u0027\u0027) \u003c\u003d Maximum_No_of_blocks_for_MAC)) \u003d\u003e (Maximum_No_of_blocks_for_MAC \u003e\u003d 0)))","non-zero obligation in \u0027DEFAULT\u0027 (MAASL.vdmsl) at line 51:17: (forall M:seq of (DEFAULT`Bit) \u0026 ((not (((len M) mod Word_Length) \u003d 0)) \u003d\u003e (Word_Length \u003c\u003e 0)))","type compatibility obligation in \u0027DEFAULT\u0027 (MAASL.vdmsl) at line 224:4: (forall M:DEFAULT`Message_in_blocks, P:DEFAULT`Number \u0026 (inv_Message_in_blocks((if ((len M) \u003d 1)\nthen [Condition_value((hd M), P)]\nelse ([Condition_value((hd M), P)] ^ Condition_Sequence((tl M), Changes((hd M), P))))) and inv_Message_in_blocks_plus_empty_Message((if ((len M) \u003d 1)\nthen [Condition_value((hd M), P)]\nelse ([Condition_value((hd M), P)] ^ Condition_Sequence((tl M), Changes((hd M), P)))))))","type compatibility obligation in \u0027DEFAULT\u0027 (MAASL.vdmsl) at line 136:42: (forall X:DEFAULT`Number, Y:DEFAULT`Number \u0026 ((not ((X \u003d 0) or (Y \u003d 0))) \u003d\u003e (inv_Number((X div 2)) and is_((X div 2), nat))))","type compatibility obligation in \u0027DEFAULT\u0027 (MAASL.vdmsl) at line 352:14: (forall M:DEFAULT`Message_in_blocks, K:DEFAULT`Key \u0026 let KC:DEFAULT`Key_Constant \u003d Prelude(K) in let S:DEFAULT`Number \u003d (KC.S), T:DEFAULT`Number \u003d (KC.T) in let M\u0027:seq1 of (DEFAULT`Number) \u003d ((M ^ [S]) ^ [T]) in inv_Message_in_blocks_plus_empty_Message(M\u0027))","non-empty sequence obligation in \u0027DEFAULT\u0027 (MAASL.vdmsl) at line 267:22: (forall M:DEFAULT`Message_in_blocks, P:DEFAULT`Number \u0026 (((len M) \u003d 1) \u003d\u003e (M \u003c\u003e [])))","non-empty sequence obligation in \u0027DEFAULT\u0027 (MAASL.vdmsl) at line 207:20: (forall K:DEFAULT`Double_Number \u0026 (K \u003c\u003e []))","non-empty sequence obligation in \u0027DEFAULT\u0027 (MAASL.vdmsl) at line 229:47: (forall M:DEFAULT`Message_in_blocks, P:DEFAULT`Number \u0026 ((not ((len M) \u003d 1)) \u003d\u003e (M \u003c\u003e [])))","legal function application obligation in \u0027DEFAULT\u0027 (MAASL.vdmsl) at line 208:14: (forall K:DEFAULT`Double_Number \u0026 let X:DEFAULT`Number \u003d (hd K), Y:DEFAULT`Number \u003d (hd (tl K)) in pre_Byte(X, 3))","legal function application obligation in \u0027DEFAULT\u0027 (MAASL.vdmsl) at line 259:24: (forall D:DEFAULT`Double_Number \u0026 let X:DEFAULT`Number \u003d (hd D), Y:DEFAULT`Number \u003d (hd (tl D)) in pre_Byte(Y, 2))","legal function application obligation in \u0027DEFAULT\u0027 (MAASL.vdmsl) at line 367:21: (forall M:DEFAULT`Message_in_bits, K:DEFAULT`Key \u0026 let M\u0027:DEFAULT`Message_in_bits \u003d Pad_out_Message(M) in let M\u0027\u0027:DEFAULT`Message_in_blocks \u003d Form_Message_into_blocks(M\u0027) in ((not ((len M\u0027\u0027) \u003c\u003d Maximum_No_of_blocks_for_MAC)) \u003d\u003e pre_Get_tail_in_blocks(M\u0027\u0027, Maximum_No_of_blocks_for_MAC)))","type compatibility obligation in \u0027DEFAULT\u0027 (MAASL.vdmsl) at line 333:24: (forall M:DEFAULT`Message_in_blocks_plus_empty_Message, KC:DEFAULT`Key_Constant \u0026 let mk_Key_Constant(X, Y, V, W, S, T):DEFAULT`Key_Constant \u003d KC in ((not ((len M) \u003d 0)) \u003d\u003e let Mi:DEFAULT`Number \u003d (hd M) in let V\u0027:DEFAULT`Number \u003d CYC(V) in let E:DEFAULT`Number \u003d XOR(V\u0027, W), X\u0027:DEFAULT`Number \u003d XOR(X, Mi), Y\u0027:DEFAULT`Number \u003d XOR(Y, Mi) in let F:DEFAULT`Number \u003d ADD(E, Y\u0027), G:DEFAULT`Number \u003d ADD(E, X\u0027) in inv_Number(B)))","non-empty sequence obligation in \u0027DEFAULT\u0027 (MAASL.vdmsl) at line 229:33: (forall M:DEFAULT`Message_in_blocks, P:DEFAULT`Number \u0026 ((not ((len M) \u003d 1)) \u003d\u003e (M \u003c\u003e [])))","non-empty sequence obligation in \u0027DEFAULT\u0027 (MAASL.vdmsl) at line 112:38: (forall M:DEFAULT`Message_in_bits \u0026 (((len M) \u003c\u003d Word_Length) \u003d\u003e ((not ((len M) \u003d 1)) \u003d\u003e (M \u003c\u003e []))))","legal function application obligation in \u0027DEFAULT\u0027 (MAASL.vdmsl) at line 362:14: (forall M:DEFAULT`Message_in_bits, K:DEFAULT`Key \u0026 let M\u0027:DEFAULT`Message_in_bits \u003d Pad_out_Message(M) in pre_Form_Message_into_blocks(M\u0027))","non-empty sequence obligation in \u0027DEFAULT\u0027 (MAASL.vdmsl) at line 111:29: (forall M:DEFAULT`Message_in_bits \u0026 (((len M) \u003c\u003d Word_Length) \u003d\u003e (((len M) \u003d 1) \u003d\u003e (M \u003c\u003e []))))","legal function application obligation in \u0027DEFAULT\u0027 (MAASL.vdmsl) at line 214:14: (forall K:DEFAULT`Double_Number \u0026 let X:DEFAULT`Number \u003d (hd K), Y:DEFAULT`Number \u003d (hd (tl K)) in let X\u0027:seq1 of (DEFAULT`Number) \u003d [Byte(X, 3), Byte(X, 2), Byte(X, 1), Byte(X, 0)], Y\u0027:seq1 of (DEFAULT`Number) \u003d [Byte(Y, 3), Byte(Y, 2), Byte(Y, 1), Byte(X, 0)] in let XY:seq1 of (DEFAULT`Number) \u003d (X\u0027 ^ Y\u0027), P:nat \u003d 0 in let XY\u0027:DEFAULT`Message_in_blocks \u003d Condition_Sequence(XY, P) in pre_Get_tail_in_blocks(XY\u0027, 4))","non-empty sequence obligation in \u0027DEFAULT\u0027 (MAASL.vdmsl) at line 388:31: (forall M:DEFAULT`Message_in_bits, No_bits:nat \u0026 (((len M) \u003e\u003d No_bits) \u003d\u003e ((not (No_bits \u003d 0)) \u003d\u003e (M \u003c\u003e []))))","non-empty sequence obligation in \u0027DEFAULT\u0027 (MAASL.vdmsl) at line 257:20: (forall D:DEFAULT`Double_Number \u0026 (D \u003c\u003e []))","type compatibility obligation in \u0027DEFAULT\u0027 (MAASL.vdmsl) at line 366:42: (forall M:DEFAULT`Message_in_bits, K:DEFAULT`Key \u0026 let M\u0027:DEFAULT`Message_in_bits \u003d Pad_out_Message(M) in let M\u0027\u0027:DEFAULT`Message_in_blocks \u003d Form_Message_into_blocks(M\u0027) in ((not ((len M\u0027\u0027) \u003c\u003d Maximum_No_of_blocks_for_MAC)) \u003d\u003e (Maximum_No_of_blocks_for_MAC \u003e\u003d 0)))","non-zero obligation in \u0027DEFAULT\u0027 (MAASL.vdmsl) at line 179:14: (forall X:DEFAULT`Number, Y:DEFAULT`Number \u0026 (Maximum_Number_Size_plus_1 \u003c\u003e 0))","legal function application obligation in \u0027DEFAULT\u0027 (MAASL.vdmsl) at line 105:23: (forall M:DEFAULT`Message_in_bits \u0026 ((((len M) \u003e\u003d Word_Length) and (((len M) mod Word_Length) \u003d 0)) \u003d\u003e ((not ((len M) \u003d Word_Length)) \u003d\u003e pre_Get_head_in_bits(M, Word_Length))))","type compatibility obligation in \u0027DEFAULT\u0027 (MAASL.vdmsl) at line 130:48: (forall X:DEFAULT`Number, Y:DEFAULT`Number \u0026 ((not ((X \u003d 0) or (Y \u003d 0))) \u003d\u003e (inv_Number((Y div 2)) and is_((Y div 2), nat))))","non-empty sequence obligation in \u0027DEFAULT\u0027 (MAASL.vdmsl) at line 281:21: (forall K:DEFAULT`Key \u0026 let J1K1:DEFAULT`Double_Number \u003d BYT(K) in (J1K1 \u003c\u003e []))","non-empty sequence obligation in \u0027DEFAULT\u0027 (MAASL.vdmsl) at line 268:43: (forall M:DEFAULT`Message_in_blocks, P:DEFAULT`Number \u0026 ((not ((len M) \u003d 1)) \u003d\u003e (M \u003c\u003e [])))","non-empty sequence obligation in \u0027DEFAULT\u0027 (MAASL.vdmsl) at line 312:77: (forall K:DEFAULT`Key \u0026 let J1K1:DEFAULT`Double_Number \u003d BYT(K) in let J1:DEFAULT`Number \u003d (hd J1K1), K1:DEFAULT`Number \u003d (hd (tl J1K1)), P:DEFAULT`Number \u003d PAT(K), Q:nat1 \u003d ((1 + P) * (1 + P)) in let J12:DEFAULT`Number \u003d MUL1(J1, J1), J22:DEFAULT`Number \u003d MUL2(J1, J1) in let J14:DEFAULT`Number \u003d MUL1(J12, J12), J24:DEFAULT`Number \u003d MUL2(J22, J22) in let J16:DEFAULT`Number \u003d MUL1(J12, J14), J26:DEFAULT`Number \u003d MUL2(J22, J24) in let J18:DEFAULT`Number \u003d MUL1(J12, J16), J28:DEFAULT`Number \u003d MUL2(J22, J26) in let H4:DEFAULT`Number \u003d XOR(J14, J28), H6:DEFAULT`Number \u003d XOR(J16, J26), H8:DEFAULT`Number \u003d XOR(J18, J28) in let K12:DEFAULT`Number \u003d MUL1(K1, K1), K22:DEFAULT`Number \u003d MUL2(K1, K1) in let K14:DEFAULT`Number \u003d MUL1(K12, K12), K24:DEFAULT`Number \u003d MUL2(K22, K22) in let K15:DEFAULT`Number \u003d MUL1(K1, K14), K25:DEFAULT`Number \u003d MUL2(K1, K24) in let K17:DEFAULT`Number \u003d MUL1(K12, K15), K27:DEFAULT`Number \u003d MUL2(K22, K25) in let K19:DEFAULT`Number \u003d MUL1(K12, K17), K29:DEFAULT`Number \u003d MUL2(K22, K27) in let H\u0027:DEFAULT`Number \u003d XOR(K15, K25) in let H5:DEFAULT`Number \u003d MUL2(H\u0027, Q), H7:DEFAULT`Number \u003d XOR(K17, K27), H9:DEFAULT`Number \u003d XOR(K19, K29) in let X0Y0:DEFAULT`Double_Number \u003d BYT([H4, H5]), V0W:DEFAULT`Double_Number \u003d BYT([H6, H7]), ST:DEFAULT`Double_Number \u003d BYT([H8, H9]) in (ST \u003c\u003e []))","legal function application obligation in \u0027DEFAULT\u0027 (MAASL.vdmsl) at line 112:22: (forall M:DEFAULT`Message_in_bits \u0026 (((len M) \u003c\u003d Word_Length) \u003d\u003e ((not ((len M) \u003d 1)) \u003d\u003e pre_Form_Number((tl M)))))","legal function application obligation in \u0027DEFAULT\u0027 (MAASL.vdmsl) at line 259:44: (forall D:DEFAULT`Double_Number \u0026 let X:DEFAULT`Number \u003d (hd D), Y:DEFAULT`Number \u003d (hd (tl D)) in pre_Byte(Y, 0))","type compatibility obligation in \u0027DEFAULT\u0027 (MAASL.vdmsl) at line 169:12: (forall X:DEFAULT`Number, Y:DEFAULT`Number \u0026 let L:int \u003d ((X * Y) mod Maximum_Number_Size_plus_1), U:int \u003d ((X * Y) div Maximum_Number_Size_plus_1) in (inv_Number(U) and is_(U, nat)))","type compatibility obligation in \u0027DEFAULT\u0027 (MAASL.vdmsl) at line 240:4: (forall B:DEFAULT`Number, P:DEFAULT`Number \u0026 inv_Number(let P\u0027:nat \u003d (2 * P) in let P\u0027\u0027:nat1 \u003d (P\u0027 + 1) in (if ((B \u003d 0) or (B \u003d ((2 ** 8) - 1)))\nthen P\u0027\u0027\nelse P\u0027)))","type compatibility obligation in \u0027DEFAULT\u0027 (MAASL.vdmsl) at line 169:14: (forall X:DEFAULT`Number, Y:DEFAULT`Number \u0026 let L:int \u003d ((X * Y) mod Maximum_Number_Size_plus_1), U:int \u003d ((X * Y) div Maximum_Number_Size_plus_1) in (inv_Number(L) and is_(L, nat)))","legal function application obligation in \u0027DEFAULT\u0027 (MAASL.vdmsl) at line 94:16: (forall M:DEFAULT`Message_in_bits \u0026 let No_Extra_bits:int \u003d (Word_Length - ((len M) mod Word_Length)) in ((not (No_Extra_bits \u003d Word_Length)) \u003d\u003e pre_Get_Application_defined_bits(M, No_Extra_bits)))","legal function application obligation in \u0027DEFAULT\u0027 (MAASL.vdmsl) at line 221:10: (forall N:DEFAULT`Number, B:nat \u0026 (((B \u003e\u003d 0) and (B \u003c\u003d 3)) \u003d\u003e ((not (B \u003d 0)) \u003d\u003e pre_Byte((N div (2 ** 8)), (B - 1)))))","type compatibility obligation in \u0027DEFAULT\u0027 (MAASL.vdmsl) at line 262:22: (forall D:DEFAULT`Double_Number \u0026 let X:DEFAULT`Number \u003d (hd D), Y:DEFAULT`Number \u003d (hd (tl D)) in let X\u0027:seq1 of (DEFAULT`Number) \u003d [Byte(X, 3), Byte(X, 2), Byte(Y, 1), Byte(Y, 0)], Y\u0027:seq1 of (DEFAULT`Number) \u003d [Byte(Y, 3), Byte(Y, 2), Byte(Y, 1), Byte(Y, 0)] in let XY:seq1 of (DEFAULT`Number) \u003d (X\u0027 ^ Y\u0027), P:nat \u003d 0 in inv_Number(P))","non-empty sequence obligation in \u0027DEFAULT\u0027 (MAASL.vdmsl) at line 227:31: (forall M:DEFAULT`Message_in_blocks, P:DEFAULT`Number \u0026 (((len M) \u003d 1) \u003d\u003e (M \u003c\u003e [])))","type compatibility obligation in \u0027DEFAULT\u0027 (MAASL.vdmsl) at line 391:4: (forall M:DEFAULT`Message_in_bits, No_bits:nat \u0026 ((((len M) \u003e\u003d No_bits) and (No_bits \u003e\u003d 1)) \u003d\u003e inv_Message_in_bits((if (No_bits \u003d 0)\nthen [(hd M)]\nelse ([(hd M)] ^ Get_head_in_bits((tl M), (No_bits - 1)))))))","legal function application obligation in \u0027DEFAULT\u0027 (MAASL.vdmsl) at line 106:10: (forall M:DEFAULT`Message_in_bits \u0026 ((((len M) \u003e\u003d Word_Length) and (((len M) mod Word_Length) \u003d 0)) \u003d\u003e ((not ((len M) \u003d Word_Length)) \u003d\u003e pre_Form_Message_into_blocks(Get_tail_in_bits(M, Word_Length)))))","type invariant satisfiable obligation in \u0027DEFAULT\u0027 (MAASL.vdmsl) at line 53:4: (exists M:DEFAULT`Message_in_blocks_plus_empty_Message \u0026 ((len M) \u003c\u003d Maximum_No_of_Message_blocks))","type compatibility obligation in \u0027DEFAULT\u0027 (MAASL.vdmsl) at line 388:41: (forall M:DEFAULT`Message_in_bits, No_bits:nat \u0026 (((len M) \u003e\u003d No_bits) \u003d\u003e ((not (No_bits \u003d 0)) \u003d\u003e ((No_bits - 1) \u003e\u003d 0))))","non-empty sequence obligation in \u0027DEFAULT\u0027 (MAASL.vdmsl) at line 256:16: (forall D:DEFAULT`Double_Number \u0026 (D \u003c\u003e []))","non-empty sequence obligation in \u0027DEFAULT\u0027 (MAASL.vdmsl) at line 408:15: (forall M:DEFAULT`Message_in_blocks, No_blocks:nat \u0026 ((((len M) \u003e\u003d No_blocks) and (No_blocks \u003e\u003d 1)) \u003d\u003e ((No_blocks \u003d 0) \u003d\u003e (M \u003c\u003e []))))","non-zero obligation in \u0027DEFAULT\u0027 (MAASL.vdmsl) at line 192:14: (forall X:DEFAULT`Number, Y:DEFAULT`Number \u0026 ((((X div Maximum_Number_Size_plus_1_div_2) \u003d 0) or ((Y div Maximum_Number_Size_plus_1_div_2) \u003d 0)) \u003d\u003e (Maximum_Number_Size_plus_1 \u003c\u003e 0)))","legal function application obligation in \u0027DEFAULT\u0027 (MAASL.vdmsl) at line 105:11: (forall M:DEFAULT`Message_in_bits \u0026 ((((len M) \u003e\u003d Word_Length) and (((len M) mod Word_Length) \u003d 0)) \u003d\u003e ((not ((len M) \u003d Word_Length)) \u003d\u003e pre_Form_Number(Get_head_in_bits(M, Word_Length)))))","legal function application obligation in \u0027DEFAULT\u0027 (MAASL.vdmsl) at line 209:44: (forall K:DEFAULT`Double_Number \u0026 let X:DEFAULT`Number \u003d (hd K), Y:DEFAULT`Number \u003d (hd (tl K)) in pre_Byte(X, 0))","type compatibility obligation in \u0027DEFAULT\u0027 (MAASL.vdmsl) at line 309:19: (forall K:DEFAULT`Key \u0026 let J1K1:DEFAULT`Double_Number \u003d BYT(K) in let J1:DEFAULT`Number \u003d (hd J1K1), K1:DEFAULT`Number \u003d (hd (tl J1K1)), P:DEFAULT`Number \u003d PAT(K), Q:nat1 \u003d ((1 + P) * (1 + P)) in let J12:DEFAULT`Number \u003d MUL1(J1, J1), J22:DEFAULT`Number \u003d MUL2(J1, J1) in let J14:DEFAULT`Number \u003d MUL1(J12, J12), J24:DEFAULT`Number \u003d MUL2(J22, J22) in let J16:DEFAULT`Number \u003d MUL1(J12, J14), J26:DEFAULT`Number \u003d MUL2(J22, J24) in let J18:DEFAULT`Number \u003d MUL1(J12, J16), J28:DEFAULT`Number \u003d MUL2(J22, J26) in let H4:DEFAULT`Number \u003d XOR(J14, J28), H6:DEFAULT`Number \u003d XOR(J16, J26), H8:DEFAULT`Number \u003d XOR(J18, J28) in let K12:DEFAULT`Number \u003d MUL1(K1, K1), K22:DEFAULT`Number \u003d MUL2(K1, K1) in let K14:DEFAULT`Number \u003d MUL1(K12, K12), K24:DEFAULT`Number \u003d MUL2(K22, K22) in let K15:DEFAULT`Number \u003d MUL1(K1, K14), K25:DEFAULT`Number \u003d MUL2(K1, K24) in let K17:DEFAULT`Number \u003d MUL1(K12, K15), K27:DEFAULT`Number \u003d MUL2(K22, K25) in let K19:DEFAULT`Number \u003d MUL1(K12, K17), K29:DEFAULT`Number \u003d MUL2(K22, K27) in let H\u0027:DEFAULT`Number \u003d XOR(K15, K25) in let H5:DEFAULT`Number \u003d MUL2(H\u0027, Q), H7:DEFAULT`Number \u003d XOR(K17, K27), H9:DEFAULT`Number \u003d XOR(K19, K29) in inv_Double_Number([H4, H5]))","type compatibility obligation in \u0027DEFAULT\u0027 (MAASL.vdmsl) at line 368:24: (forall M:DEFAULT`Message_in_bits, K:DEFAULT`Key \u0026 let M\u0027:DEFAULT`Message_in_bits \u003d Pad_out_Message(M) in let M\u0027\u0027:DEFAULT`Message_in_blocks \u003d Form_Message_into_blocks(M\u0027) in ((not ((len M\u0027\u0027) \u003c\u003d Maximum_No_of_blocks_for_MAC)) \u003d\u003e let M\u0027\u0027\u0027:seq1 of (DEFAULT`Number) \u003d ([Z(Get_head_in_blocks(M\u0027\u0027, Maximum_No_of_blocks_for_MAC), K)] ^ Get_tail_in_blocks(M\u0027\u0027, Maximum_No_of_blocks_for_MAC)) in (Maximum_No_of_blocks_for_MAC_plus_1 \u003e\u003d 0)))","type invariant satisfiable obligation in \u0027DEFAULT\u0027 (MAASL.vdmsl) at line 46:4: (exists M:DEFAULT`Message_in_bits \u0026 (if (((len M) mod Word_Length) \u003d 0)\nthen ((((len M) div Word_Length) \u003c\u003d Maximum_No_of_Message_blocks) and ((len M) \u003e 0))\nelse ((((len M) div Word_Length) + 1) \u003c\u003d Maximum_No_of_Message_blocks)))","legal function application obligation in \u0027DEFAULT\u0027 (MAASL.vdmsl) at line 259:34: (forall D:DEFAULT`Double_Number \u0026 let X:DEFAULT`Number \u003d (hd D), Y:DEFAULT`Number \u003d (hd (tl D)) in pre_Byte(Y, 1))","type compatibility obligation in \u0027DEFAULT\u0027 (MAASL.vdmsl) at line 130:40: (forall X:DEFAULT`Number, Y:DEFAULT`Number \u0026 ((not ((X \u003d 0) or (Y \u003d 0))) \u003d\u003e (inv_Number((X div 2)) and is_((X div 2), nat))))","type compatibility obligation in \u0027DEFAULT\u0027 (MAASL.vdmsl) at line 212:33: (forall K:DEFAULT`Double_Number \u0026 let X:DEFAULT`Number \u003d (hd K), Y:DEFAULT`Number \u003d (hd (tl K)) in let X\u0027:seq1 of (DEFAULT`Number) \u003d [Byte(X, 3), Byte(X, 2), Byte(X, 1), Byte(X, 0)], Y\u0027:seq1 of (DEFAULT`Number) \u003d [Byte(Y, 3), Byte(Y, 2), Byte(Y, 1), Byte(X, 0)] in let XY:seq1 of (DEFAULT`Number) \u003d (X\u0027 ^ Y\u0027), P:nat \u003d 0 in (inv_Message_in_blocks(XY) and inv_Message_in_blocks_plus_empty_Message(XY)))","non-empty sequence obligation in \u0027DEFAULT\u0027 (MAASL.vdmsl) at line 395:43: (forall M:DEFAULT`Message_in_bits, No_bits:nat \u0026 ((((len M) \u003e\u003d No_bits) and (No_bits \u003e\u003d 1)) \u003d\u003e ((not (No_bits \u003d 0)) \u003d\u003e (M \u003c\u003e []))))","non-zero obligation in \u0027DEFAULT\u0027 (MAASL.vdmsl) at line 49:18: (forall M:seq of (DEFAULT`Bit) \u0026 ((((len M) mod Word_Length) \u003d 0) \u003d\u003e (Word_Length \u003c\u003e 0)))","type compatibility obligation in \u0027DEFAULT\u0027 (MAASL.vdmsl) at line 193:18: (forall X:DEFAULT`Number, Y:DEFAULT`Number \u0026 ((((X div Maximum_Number_Size_plus_1_div_2) \u003d 0) or ((Y div Maximum_Number_Size_plus_1_div_2) \u003d 0)) \u003d\u003e let L:int \u003d ((X * Y) mod Maximum_Number_Size_plus_1), U:int \u003d ((X * Y) div Maximum_Number_Size_plus_1) in (inv_Number(U) and is_(U, nat))))","type invariant satisfiable obligation in \u0027DEFAULT\u0027 (MAASL.vdmsl) at line 56:4: (exists M:DEFAULT`Message_in_blocks \u0026 (1 \u003c\u003d (len M)))","type compatibility obligation in \u0027DEFAULT\u0027 (MAASL.vdmsl) at line 217:4: (forall N:DEFAULT`Number, B:nat \u0026 (((B \u003e\u003d 0) and (B \u003c\u003d 3)) \u003d\u003e (inv_Number((if (B \u003d 0)\nthen (N mod (2 ** 8))\nelse Byte((N div (2 ** 8)), (B - 1)))) and is_((if (B \u003d 0)\nthen (N mod (2 ** 8))\nelse Byte((N div (2 ** 8)), (B - 1))), nat))))","type compatibility obligation in \u0027DEFAULT\u0027 (MAASL.vdmsl) at line 181:28: (forall X:DEFAULT`Number, Y:DEFAULT`Number \u0026 let L:int \u003d ((X * Y) mod Maximum_Number_Size_plus_1), U:int \u003d ((X * Y) div Maximum_Number_Size_plus_1) in let D:DEFAULT`Number \u003d ADD(U, U), E:DEFAULT`Number \u003d CAR(U, U) in let F:DEFAULT`Number \u003d ADD(D, (2 * E)) in let S:DEFAULT`Number \u003d ADD(F, L), C:DEFAULT`Number \u003d CAR(F, L) in inv_Number((2 * C)))","type compatibility obligation in \u0027DEFAULT\u0027 (MAASL.vdmsl) at line 194:18: (forall X:DEFAULT`Number, Y:DEFAULT`Number \u0026 ((((X div Maximum_Number_Size_plus_1_div_2) \u003d 0) or ((Y div Maximum_Number_Size_plus_1_div_2) \u003d 0)) \u003d\u003e let L:int \u003d ((X * Y) mod Maximum_Number_Size_plus_1), U:int \u003d ((X * Y) div Maximum_Number_Size_plus_1) in let D:DEFAULT`Number \u003d ADD(U, U) in (inv_Number(L) and is_(L, nat))))","non-empty sequence obligation in \u0027DEFAULT\u0027 (MAASL.vdmsl) at line 280:17: (forall K:DEFAULT`Key \u0026 let J1K1:DEFAULT`Double_Number \u003d BYT(K) in (J1K1 \u003c\u003e []))","non-empty sequence obligation in \u0027DEFAULT\u0027 (MAASL.vdmsl) at line 395:15: (forall M:DEFAULT`Message_in_bits, No_bits:nat \u0026 ((((len M) \u003e\u003d No_bits) and (No_bits \u003e\u003d 1)) \u003d\u003e ((not (No_bits \u003d 0)) \u003d\u003e (M \u003c\u003e []))))","legal function application obligation in \u0027DEFAULT\u0027 (MAASL.vdmsl) at line 395:22: (forall M:DEFAULT`Message_in_bits, No_bits:nat \u0026 ((((len M) \u003e\u003d No_bits) and (No_bits \u003e\u003d 1)) \u003d\u003e ((not (No_bits \u003d 0)) \u003d\u003e pre_Get_head_in_bits((tl M), (No_bits - 1)))))","legal function application obligation in \u0027DEFAULT\u0027 (MAASL.vdmsl) at line 258:14: (forall D:DEFAULT`Double_Number \u0026 let X:DEFAULT`Number \u003d (hd D), Y:DEFAULT`Number \u003d (hd (tl D)) in pre_Byte(X, 3))","non-empty sequence obligation in \u0027DEFAULT\u0027 (MAASL.vdmsl) at line 312:55: (forall K:DEFAULT`Key \u0026 let J1K1:DEFAULT`Double_Number \u003d BYT(K) in let J1:DEFAULT`Number \u003d (hd J1K1), K1:DEFAULT`Number \u003d (hd (tl J1K1)), P:DEFAULT`Number \u003d PAT(K), Q:nat1 \u003d ((1 + P) * (1 + P)) in let J12:DEFAULT`Number \u003d MUL1(J1, J1), J22:DEFAULT`Number \u003d MUL2(J1, J1) in let J14:DEFAULT`Number \u003d MUL1(J12, J12), J24:DEFAULT`Number \u003d MUL2(J22, J22) in let J16:DEFAULT`Number \u003d MUL1(J12, J14), J26:DEFAULT`Number \u003d MUL2(J22, J24) in let J18:DEFAULT`Number \u003d MUL1(J12, J16), J28:DEFAULT`Number \u003d MUL2(J22, J26) in let H4:DEFAULT`Number \u003d XOR(J14, J28), H6:DEFAULT`Number \u003d XOR(J16, J26), H8:DEFAULT`Number \u003d XOR(J18, J28) in let K12:DEFAULT`Number \u003d MUL1(K1, K1), K22:DEFAULT`Number \u003d MUL2(K1, K1) in let K14:DEFAULT`Number \u003d MUL1(K12, K12), K24:DEFAULT`Number \u003d MUL2(K22, K22) in let K15:DEFAULT`Number \u003d MUL1(K1, K14), K25:DEFAULT`Number \u003d MUL2(K1, K24) in let K17:DEFAULT`Number \u003d MUL1(K12, K15), K27:DEFAULT`Number \u003d MUL2(K22, K25) in let K19:DEFAULT`Number \u003d MUL1(K12, K17), K29:DEFAULT`Number \u003d MUL2(K22, K27) in let H\u0027:DEFAULT`Number \u003d XOR(K15, K25) in let H5:DEFAULT`Number \u003d MUL2(H\u0027, Q), H7:DEFAULT`Number \u003d XOR(K17, K27), H9:DEFAULT`Number \u003d XOR(K19, K29) in let X0Y0:DEFAULT`Double_Number \u003d BYT([H4, H5]), V0W:DEFAULT`Double_Number \u003d BYT([H6, H7]), ST:DEFAULT`Double_Number \u003d BYT([H8, H9]) in ((tl V0W) \u003c\u003e []))","type compatibility obligation in \u0027DEFAULT\u0027 (MAASL.vdmsl) at line 150:4: (forall X:DEFAULT`Number, Y:DEFAULT`Number \u0026 (inv_Number(((X + Y) mod Maximum_Number_Size_plus_1)) and is_(((X + Y) mod Maximum_Number_Size_plus_1), nat)))","legal function application obligation in \u0027DEFAULT\u0027 (MAASL.vdmsl) at line 374:22: (forall M:DEFAULT`Message_in_blocks, K:DEFAULT`Key, No_blocks:nat \u0026 ((not ((len M) \u003c\u003d No_blocks)) \u003d\u003e pre_Get_head_in_blocks(M, No_blocks)))","type compatibility obligation in \u0027DEFAULT\u0027 (MAASL.vdmsl) at line 195:14: (forall X:DEFAULT`Number, Y:DEFAULT`Number \u0026 ((((X div Maximum_Number_Size_plus_1_div_2) \u003d 0) or ((Y div Maximum_Number_Size_plus_1_div_2) \u003d 0)) \u003d\u003e let L:int \u003d ((X * Y) mod Maximum_Number_Size_plus_1), U:int \u003d ((X * Y) div Maximum_Number_Size_plus_1) in let D:DEFAULT`Number \u003d ADD(U, U) in (inv_Number(L) and is_(L, nat))))","legal function application obligation in \u0027DEFAULT\u0027 (MAASL.vdmsl) at line 402:10: (forall M:DEFAULT`Message_in_blocks, No_blocks:nat \u0026 (((len M) \u003e\u003d No_blocks) \u003d\u003e ((not (No_blocks \u003d 0)) \u003d\u003e pre_Get_tail_in_blocks((tl M), (No_blocks - 1)))))","legal function application obligation in \u0027DEFAULT\u0027 (MAASL.vdmsl) at line 104:11: (forall M:DEFAULT`Message_in_bits \u0026 ((((len M) \u003e\u003d Word_Length) and (((len M) mod Word_Length) \u003d 0)) \u003d\u003e (((len M) \u003d Word_Length) \u003d\u003e pre_Form_Number(M))))","non-zero obligation in \u0027DEFAULT\u0027 (MAASL.vdmsl) at line 167:14: (forall X:DEFAULT`Number, Y:DEFAULT`Number \u0026 (Maximum_Number_Size_plus_1 \u003c\u003e 0))","type compatibility obligation in \u0027DEFAULT\u0027 (MAASL.vdmsl) at line 409:57: (forall M:DEFAULT`Message_in_blocks, No_blocks:nat \u0026 ((((len M) \u003e\u003d No_blocks) and (No_blocks \u003e\u003d 1)) \u003d\u003e ((not (No_blocks \u003d 0)) \u003d\u003e ((No_blocks - 1) \u003e\u003d 0))))","non-empty sequence obligation in \u0027DEFAULT\u0027 (MAASL.vdmsl) at line 409:15: (forall M:DEFAULT`Message_in_blocks, No_blocks:nat \u0026 ((((len M) \u003e\u003d No_blocks) and (No_blocks \u003e\u003d 1)) \u003d\u003e ((not (No_blocks \u003d 0)) \u003d\u003e (M \u003c\u003e []))))","non-zero obligation in \u0027DEFAULT\u0027 (MAASL.vdmsl) at line 196:11: (forall X:DEFAULT`Number, Y:DEFAULT`Number \u0026 (Maximum_Number_Size_plus_1_div_2 \u003c\u003e 0))","non-empty sequence obligation in \u0027DEFAULT\u0027 (MAASL.vdmsl) at line 207:17: (forall K:DEFAULT`Double_Number \u0026 ((tl K) \u003c\u003e []))","legal function application obligation in \u0027DEFAULT\u0027 (MAASL.vdmsl) at line 208:24: (forall K:DEFAULT`Double_Number \u0026 let X:DEFAULT`Number \u003d (hd K), Y:DEFAULT`Number \u003d (hd (tl K)) in pre_Byte(X, 2))","type compatibility obligation in \u0027DEFAULT\u0027 (MAASL.vdmsl) at line 144:4: (forall X:DEFAULT`Number, Y:DEFAULT`Number \u0026 (inv_Number((if ((X \u003d 0) or (Y \u003d 0))\nthen (X + Y)\nelse (((X + Y) mod 2) + (2 * XOR((X div 2), (Y div 2)))))) and is_((if ((X \u003d 0) or (Y \u003d 0))\nthen (X + Y)\nelse (((X + Y) mod 2) + (2 * XOR((X div 2), (Y div 2))))), nat)))","type compatibility obligation in \u0027DEFAULT\u0027 (MAASL.vdmsl) at line 132:4: (forall X:DEFAULT`Number, Y:DEFAULT`Number \u0026 (inv_Number((if ((X \u003d 0) or (Y \u003d 0))\nthen (X + Y)\nelse (max((X mod 2), (Y mod 2)) + (2 * OR((X div 2), (Y div 2)))))) and is_((if ((X \u003d 0) or (Y \u003d 0))\nthen (X + Y)\nelse (max((X mod 2), (Y mod 2)) + (2 * OR((X div 2), (Y div 2))))), nat)))","type compatibility obligation in \u0027DEFAULT\u0027 (MAASL.vdmsl) at line 221:29: (forall N:DEFAULT`Number, B:nat \u0026 (((B \u003e\u003d 0) and (B \u003c\u003d 3)) \u003d\u003e ((not (B \u003d 0)) \u003d\u003e ((B - 1) \u003e\u003d 0))))","type compatibility obligation in \u0027DEFAULT\u0027 (MAASL.vdmsl) at line 306:21: (forall K:DEFAULT`Key \u0026 let J1K1:DEFAULT`Double_Number \u003d BYT(K) in let J1:DEFAULT`Number \u003d (hd J1K1), K1:DEFAULT`Number \u003d (hd (tl J1K1)), P:DEFAULT`Number \u003d PAT(K), Q:nat1 \u003d ((1 + P) * (1 + P)) in let J12:DEFAULT`Number \u003d MUL1(J1, J1), J22:DEFAULT`Number \u003d MUL2(J1, J1) in let J14:DEFAULT`Number \u003d MUL1(J12, J12), J24:DEFAULT`Number \u003d MUL2(J22, J22) in let J16:DEFAULT`Number \u003d MUL1(J12, J14), J26:DEFAULT`Number \u003d MUL2(J22, J24) in let J18:DEFAULT`Number \u003d MUL1(J12, J16), J28:DEFAULT`Number \u003d MUL2(J22, J26) in let H4:DEFAULT`Number \u003d XOR(J14, J28), H6:DEFAULT`Number \u003d XOR(J16, J26), H8:DEFAULT`Number \u003d XOR(J18, J28) in let K12:DEFAULT`Number \u003d MUL1(K1, K1), K22:DEFAULT`Number \u003d MUL2(K1, K1) in let K14:DEFAULT`Number \u003d MUL1(K12, K12), K24:DEFAULT`Number \u003d MUL2(K22, K22) in let K15:DEFAULT`Number \u003d MUL1(K1, K14), K25:DEFAULT`Number \u003d MUL2(K1, K24) in let K17:DEFAULT`Number \u003d MUL1(K12, K15), K27:DEFAULT`Number \u003d MUL2(K22, K25) in let K19:DEFAULT`Number \u003d MUL1(K12, K17), K29:DEFAULT`Number \u003d MUL2(K22, K27) in let H\u0027:DEFAULT`Number \u003d XOR(K15, K25) in inv_Number(Q))","legal function application obligation in \u0027DEFAULT\u0027 (MAASL.vdmsl) at line 366:19: (forall M:DEFAULT`Message_in_bits, K:DEFAULT`Key \u0026 let M\u0027:DEFAULT`Message_in_bits \u003d Pad_out_Message(M) in let M\u0027\u0027:DEFAULT`Message_in_blocks \u003d Form_Message_into_blocks(M\u0027) in ((not ((len M\u0027\u0027) \u003c\u003d Maximum_No_of_blocks_for_MAC)) \u003d\u003e pre_Get_head_in_blocks(M\u0027\u0027, Maximum_No_of_blocks_for_MAC)))","type compatibility obligation in \u0027DEFAULT\u0027 (MAASL.vdmsl) at line 122:4: (forall X:DEFAULT`Number \u0026 inv_Number((ADD(X, X) + CAR(X, X))))","non-empty sequence obligation in \u0027DEFAULT\u0027 (MAASL.vdmsl) at line 325:23: (forall M:DEFAULT`Message_in_blocks_plus_empty_Message, KC:DEFAULT`Key_Constant \u0026 let mk_Key_Constant(X, Y, V, W, S, T):DEFAULT`Key_Constant \u003d KC in ((not ((len M) \u003d 0)) \u003d\u003e (M \u003c\u003e [])))","legal function application obligation in \u0027DEFAULT\u0027 (MAASL.vdmsl) at line 208:34: (forall K:DEFAULT`Double_Number \u0026 let X:DEFAULT`Number \u003d (hd K), Y:DEFAULT`Number \u003d (hd (tl K)) in pre_Byte(X, 1))","type compatibility obligation in \u0027DEFAULT\u0027 (MAASL.vdmsl) at line 248:4: (forall M:DEFAULT`Message_in_blocks \u0026 inv_Number((if ((len M) \u003d 1)\nthen (hd M)\nelse (Convert_Bytes_to_Number((tl M)) + ((hd M) * (2 ** (8 * ((len M) - 1))))))))","non-empty sequence obligation in \u0027DEFAULT\u0027 (MAASL.vdmsl) at line 312:66: (forall K:DEFAULT`Key \u0026 let J1K1:DEFAULT`Double_Number \u003d BYT(K) in let J1:DEFAULT`Number \u003d (hd J1K1), K1:DEFAULT`Number \u003d (hd (tl J1K1)), P:DEFAULT`Number \u003d PAT(K), Q:nat1 \u003d ((1 + P) * (1 + P)) in let J12:DEFAULT`Number \u003d MUL1(J1, J1), J22:DEFAULT`Number \u003d MUL2(J1, J1) in let J14:DEFAULT`Number \u003d MUL1(J12, J12), J24:DEFAULT`Number \u003d MUL2(J22, J22) in let J16:DEFAULT`Number \u003d MUL1(J12, J14), J26:DEFAULT`Number \u003d MUL2(J22, J24) in let J18:DEFAULT`Number \u003d MUL1(J12, J16), J28:DEFAULT`Number \u003d MUL2(J22, J26) in let H4:DEFAULT`Number \u003d XOR(J14, J28), H6:DEFAULT`Number \u003d XOR(J16, J26), H8:DEFAULT`Number \u003d XOR(J18, J28) in let K12:DEFAULT`Number \u003d MUL1(K1, K1), K22:DEFAULT`Number \u003d MUL2(K1, K1) in let K14:DEFAULT`Number \u003d MUL1(K12, K12), K24:DEFAULT`Number \u003d MUL2(K22, K22) in let K15:DEFAULT`Number \u003d MUL1(K1, K14), K25:DEFAULT`Number \u003d MUL2(K1, K24) in let K17:DEFAULT`Number \u003d MUL1(K12, K15), K27:DEFAULT`Number \u003d MUL2(K22, K25) in let K19:DEFAULT`Number \u003d MUL1(K12, K17), K29:DEFAULT`Number \u003d MUL2(K22, K27) in let H\u0027:DEFAULT`Number \u003d XOR(K15, K25) in let H5:DEFAULT`Number \u003d MUL2(H\u0027, Q), H7:DEFAULT`Number \u003d XOR(K17, K27), H9:DEFAULT`Number \u003d XOR(K19, K29) in let X0Y0:DEFAULT`Double_Number \u003d BYT([H4, H5]), V0W:DEFAULT`Double_Number \u003d BYT([H6, H7]), ST:DEFAULT`Double_Number \u003d BYT([H8, H9]) in (ST \u003c\u003e []))","non-empty sequence obligation in \u0027DEFAULT\u0027 (MAASL.vdmsl) at line 228:31: (forall M:DEFAULT`Message_in_blocks, P:DEFAULT`Number \u0026 ((not ((len M) \u003d 1)) \u003d\u003e (M \u003c\u003e [])))","non-empty sequence obligation in \u0027DEFAULT\u0027 (MAASL.vdmsl) at line 251:14: (forall M:DEFAULT`Message_in_blocks \u0026 (((len M) \u003d 1) \u003d\u003e (M \u003c\u003e [])))","type compatibility obligation in \u0027DEFAULT\u0027 (MAASL.vdmsl) at line 148:36: (forall X:DEFAULT`Number, Y:DEFAULT`Number \u0026 ((not ((X \u003d 0) or (Y \u003d 0))) \u003d\u003e (inv_Number((X div 2)) and is_((X div 2), nat))))","type compatibility obligation in \u0027DEFAULT\u0027 (MAASL.vdmsl) at line 311:17: (forall K:DEFAULT`Key \u0026 let J1K1:DEFAULT`Double_Number \u003d BYT(K) in let J1:DEFAULT`Number \u003d (hd J1K1), K1:DEFAULT`Number \u003d (hd (tl J1K1)), P:DEFAULT`Number \u003d PAT(K), Q:nat1 \u003d ((1 + P) * (1 + P)) in let J12:DEFAULT`Number \u003d MUL1(J1, J1), J22:DEFAULT`Number \u003d MUL2(J1, J1) in let J14:DEFAULT`Number \u003d MUL1(J12, J12), J24:DEFAULT`Number \u003d MUL2(J22, J22) in let J16:DEFAULT`Number \u003d MUL1(J12, J14), J26:DEFAULT`Number \u003d MUL2(J22, J24) in let J18:DEFAULT`Number \u003d MUL1(J12, J16), J28:DEFAULT`Number \u003d MUL2(J22, J26) in let H4:DEFAULT`Number \u003d XOR(J14, J28), H6:DEFAULT`Number \u003d XOR(J16, J26), H8:DEFAULT`Number \u003d XOR(J18, J28) in let K12:DEFAULT`Number \u003d MUL1(K1, K1), K22:DEFAULT`Number \u003d MUL2(K1, K1) in let K14:DEFAULT`Number \u003d MUL1(K12, K12), K24:DEFAULT`Number \u003d MUL2(K22, K22) in let K15:DEFAULT`Number \u003d MUL1(K1, K14), K25:DEFAULT`Number \u003d MUL2(K1, K24) in let K17:DEFAULT`Number \u003d MUL1(K12, K15), K27:DEFAULT`Number \u003d MUL2(K22, K25) in let K19:DEFAULT`Number \u003d MUL1(K12, K17), K29:DEFAULT`Number \u003d MUL2(K22, K27) in let H\u0027:DEFAULT`Number \u003d XOR(K15, K25) in let H5:DEFAULT`Number \u003d MUL2(H\u0027, Q), H7:DEFAULT`Number \u003d XOR(K17, K27), H9:DEFAULT`Number \u003d XOR(K19, K29) in inv_Double_Number([H8, H9]))","type compatibility obligation in \u0027DEFAULT\u0027 (MAASL.vdmsl) at line 180:36: (forall X:DEFAULT`Number, Y:DEFAULT`Number \u0026 let L:int \u003d ((X * Y) mod Maximum_Number_Size_plus_1), U:int \u003d ((X * Y) div Maximum_Number_Size_plus_1) in let D:DEFAULT`Number \u003d ADD(U, U), E:DEFAULT`Number \u003d CAR(U, U) in inv_Number((2 * E)))","non-empty sequence obligation in \u0027DEFAULT\u0027 (MAASL.vdmsl) at line 312:58: (forall K:DEFAULT`Key \u0026 let J1K1:DEFAULT`Double_Number \u003d BYT(K) in let J1:DEFAULT`Number \u003d (hd J1K1), K1:DEFAULT`Number \u003d (hd (tl J1K1)), P:DEFAULT`Number \u003d PAT(K), Q:nat1 \u003d ((1 + P) * (1 + P)) in let J12:DEFAULT`Number \u003d MUL1(J1, J1), J22:DEFAULT`Number \u003d MUL2(J1, J1) in let J14:DEFAULT`Number \u003d MUL1(J12, J12), J24:DEFAULT`Number \u003d MUL2(J22, J22) in let J16:DEFAULT`Number \u003d MUL1(J12, J14), J26:DEFAULT`Number \u003d MUL2(J22, J24) in let J18:DEFAULT`Number \u003d MUL1(J12, J16), J28:DEFAULT`Number \u003d MUL2(J22, J26) in let H4:DEFAULT`Number \u003d XOR(J14, J28), H6:DEFAULT`Number \u003d XOR(J16, J26), H8:DEFAULT`Number \u003d XOR(J18, J28) in let K12:DEFAULT`Number \u003d MUL1(K1, K1), K22:DEFAULT`Number \u003d MUL2(K1, K1) in let K14:DEFAULT`Number \u003d MUL1(K12, K12), K24:DEFAULT`Number \u003d MUL2(K22, K22) in let K15:DEFAULT`Number \u003d MUL1(K1, K14), K25:DEFAULT`Number \u003d MUL2(K1, K24) in let K17:DEFAULT`Number \u003d MUL1(K12, K15), K27:DEFAULT`Number \u003d MUL2(K22, K25) in let K19:DEFAULT`Number \u003d MUL1(K12, K17), K29:DEFAULT`Number \u003d MUL2(K22, K27) in let H\u0027:DEFAULT`Number \u003d XOR(K15, K25) in let H5:DEFAULT`Number \u003d MUL2(H\u0027, Q), H7:DEFAULT`Number \u003d XOR(K17, K27), H9:DEFAULT`Number \u003d XOR(K19, K29) in let X0Y0:DEFAULT`Double_Number \u003d BYT([H4, H5]), V0W:DEFAULT`Double_Number \u003d BYT([H6, H7]), ST:DEFAULT`Double_Number \u003d BYT([H8, H9]) in (V0W \u003c\u003e []))","non-zero obligation in \u0027DEFAULT\u0027 (MAASL.vdmsl) at line 197:11: (forall X:DEFAULT`Number, Y:DEFAULT`Number \u0026 ((not ((X div Maximum_Number_Size_plus_1_div_2) \u003d 0)) \u003d\u003e (Maximum_Number_Size_plus_1_div_2 \u003c\u003e 0)))","type compatibility obligation in \u0027DEFAULT\u0027 (MAASL.vdmsl) at line 212:36: (forall K:DEFAULT`Double_Number \u0026 let X:DEFAULT`Number \u003d (hd K), Y:DEFAULT`Number \u003d (hd (tl K)) in let X\u0027:seq1 of (DEFAULT`Number) \u003d [Byte(X, 3), Byte(X, 2), Byte(X, 1), Byte(X, 0)], Y\u0027:seq1 of (DEFAULT`Number) \u003d [Byte(Y, 3), Byte(Y, 2), Byte(Y, 1), Byte(X, 0)] in let XY:seq1 of (DEFAULT`Number) \u003d (X\u0027 ^ Y\u0027), P:nat \u003d 0 in inv_Number(P))","legal function application obligation in \u0027DEFAULT\u0027 (MAASL.vdmsl) at line 209:34: (forall K:DEFAULT`Double_Number \u0026 let X:DEFAULT`Number \u003d (hd K), Y:DEFAULT`Number \u003d (hd (tl K)) in pre_Byte(Y, 1))","type compatibility obligation in \u0027DEFAULT\u0027 (MAASL.vdmsl) at line 334:27: (forall M:DEFAULT`Message_in_blocks_plus_empty_Message, KC:DEFAULT`Key_Constant \u0026 let mk_Key_Constant(X, Y, V, W, S, T):DEFAULT`Key_Constant \u003d KC in ((not ((len M) \u003d 0)) \u003d\u003e let Mi:DEFAULT`Number \u003d (hd M) in let V\u0027:DEFAULT`Number \u003d CYC(V) in let E:DEFAULT`Number \u003d XOR(V\u0027, W), X\u0027:DEFAULT`Number \u003d XOR(X, Mi), Y\u0027:DEFAULT`Number \u003d XOR(Y, Mi) in let F:DEFAULT`Number \u003d ADD(E, Y\u0027), G:DEFAULT`Number \u003d ADD(E, X\u0027) in let F\u0027:DEFAULT`Number \u003d OR(F, A), G\u0027:DEFAULT`Number \u003d OR(G, B) in inv_Number(C)))","type compatibility obligation in \u0027DEFAULT\u0027 (MAASL.vdmsl) at line 405:4: (forall M:DEFAULT`Message_in_blocks, No_blocks:nat \u0026 ((((len M) \u003e\u003d No_blocks) and (No_blocks \u003e\u003d 1)) \u003d\u003e (inv_Message_in_blocks((if (No_blocks \u003d 0)\nthen [(hd M)]\nelse ([(hd M)] ^ Get_head_in_blocks((tl M), (No_blocks - 1))))) and inv_Message_in_blocks_plus_empty_Message((if (No_blocks \u003d 0)\nthen [(hd M)]\nelse ([(hd M)] ^ Get_head_in_blocks((tl M), (No_blocks - 1))))))))","type compatibility obligation in \u0027DEFAULT\u0027 (MAASL.vdmsl) at line 126:4: (forall X:DEFAULT`Number, Y:DEFAULT`Number \u0026 (inv_Number((if ((X \u003d 0) or (Y \u003d 0))\nthen 0\nelse ((((X mod 2) * Y) mod 2) + (2 * AND((X div 2), (Y div 2)))))) and is_((if ((X \u003d 0) or (Y \u003d 0))\nthen 0\nelse ((((X mod 2) * Y) mod 2) + (2 * AND((X div 2), (Y div 2))))), nat)))","type invariant satisfiable obligation in \u0027DEFAULT\u0027 (MAASL.vdmsl) at line 43:4: (exists b:DEFAULT`Bit \u0026 (b in set {0, 1}))","legal function application obligation in \u0027DEFAULT\u0027 (MAASL.vdmsl) at line 375:16: (forall M:DEFAULT`Message_in_blocks, K:DEFAULT`Key, No_blocks:nat \u0026 ((not ((len M) \u003c\u003d No_blocks)) \u003d\u003e pre_Get_tail_in_blocks(M, No_blocks)))","type compatibility obligation in \u0027DEFAULT\u0027 (MAASL.vdmsl) at line 402:45: (forall M:DEFAULT`Message_in_blocks, No_blocks:nat \u0026 (((len M) \u003e\u003d No_blocks) \u003d\u003e ((not (No_blocks \u003d 0)) \u003d\u003e ((No_blocks - 1) \u003e\u003d 0))))","legal function application obligation in \u0027DEFAULT\u0027 (MAASL.vdmsl) at line 409:22: (forall M:DEFAULT`Message_in_blocks, No_blocks:nat \u0026 ((((len M) \u003e\u003d No_blocks) and (No_blocks \u003e\u003d 1)) \u003d\u003e ((not (No_blocks \u003d 0)) \u003d\u003e pre_Get_head_in_blocks((tl M), (No_blocks - 1)))))","type compatibility obligation in \u0027DEFAULT\u0027 (MAASL.vdmsl) at line 136:50: (forall X:DEFAULT`Number, Y:DEFAULT`Number \u0026 ((not ((X \u003d 0) or (Y \u003d 0))) \u003d\u003e (inv_Number((Y div 2)) and is_((Y div 2), nat))))","type compatibility obligation in \u0027DEFAULT\u0027 (MAASL.vdmsl) at line 335:27: (forall M:DEFAULT`Message_in_blocks_plus_empty_Message, KC:DEFAULT`Key_Constant \u0026 let mk_Key_Constant(X, Y, V, W, S, T):DEFAULT`Key_Constant \u003d KC in ((not ((len M) \u003d 0)) \u003d\u003e let Mi:DEFAULT`Number \u003d (hd M) in let V\u0027:DEFAULT`Number \u003d CYC(V) in let E:DEFAULT`Number \u003d XOR(V\u0027, W), X\u0027:DEFAULT`Number \u003d XOR(X, Mi), Y\u0027:DEFAULT`Number \u003d XOR(Y, Mi) in let F:DEFAULT`Number \u003d ADD(E, Y\u0027), G:DEFAULT`Number \u003d ADD(E, X\u0027) in let F\u0027:DEFAULT`Number \u003d OR(F, A), G\u0027:DEFAULT`Number \u003d OR(G, B) in inv_Number(D)))","type compatibility obligation in \u0027DEFAULT\u0027 (MAASL.vdmsl) at line 168:18: (forall X:DEFAULT`Number, Y:DEFAULT`Number \u0026 let L:int \u003d ((X * Y) mod Maximum_Number_Size_plus_1), U:int \u003d ((X * Y) div Maximum_Number_Size_plus_1) in (inv_Number(L) and is_(L, nat)))","type compatibility obligation in \u0027DEFAULT\u0027 (MAASL.vdmsl) at line 221:17: (forall N:DEFAULT`Number, B:nat \u0026 (((B \u003e\u003d 0) and (B \u003c\u003d 3)) \u003d\u003e ((not (B \u003d 0)) \u003d\u003e (inv_Number((N div (2 ** 8))) and is_((N div (2 ** 8)), nat)))))","type compatibility obligation in \u0027DEFAULT\u0027 (MAASL.vdmsl) at line 109:4: (forall M:DEFAULT`Message_in_bits \u0026 (((len M) \u003c\u003d Word_Length) \u003d\u003e inv_Number((if ((len M) \u003d 1)\nthen (hd M)\nelse ((hd M) + (2 * Form_Number((tl M))))))))","legal function application obligation in \u0027DEFAULT\u0027 (MAASL.vdmsl) at line 258:24: (forall D:DEFAULT`Double_Number \u0026 let X:DEFAULT`Number \u003d (hd D), Y:DEFAULT`Number \u003d (hd (tl D)) in pre_Byte(X, 2))","non-empty sequence obligation in \u0027DEFAULT\u0027 (MAASL.vdmsl) at line 257:17: (forall D:DEFAULT`Double_Number \u0026 ((tl D) \u003c\u003e []))","type compatibility obligation in \u0027DEFAULT\u0027 (MAASL.vdmsl) at line 310:18: (forall K:DEFAULT`Key \u0026 let J1K1:DEFAULT`Double_Number \u003d BYT(K) in let J1:DEFAULT`Number \u003d (hd J1K1), K1:DEFAULT`Number \u003d (hd (tl J1K1)), P:DEFAULT`Number \u003d PAT(K), Q:nat1 \u003d ((1 + P) * (1 + P)) in let J12:DEFAULT`Number \u003d MUL1(J1, J1), J22:DEFAULT`Number \u003d MUL2(J1, J1) in let J14:DEFAULT`Number \u003d MUL1(J12, J12), J24:DEFAULT`Number \u003d MUL2(J22, J22) in let J16:DEFAULT`Number \u003d MUL1(J12, J14), J26:DEFAULT`Number \u003d MUL2(J22, J24) in let J18:DEFAULT`Number \u003d MUL1(J12, J16), J28:DEFAULT`Number \u003d MUL2(J22, J26) in let H4:DEFAULT`Number \u003d XOR(J14, J28), H6:DEFAULT`Number \u003d XOR(J16, J26), H8:DEFAULT`Number \u003d XOR(J18, J28) in let K12:DEFAULT`Number \u003d MUL1(K1, K1), K22:DEFAULT`Number \u003d MUL2(K1, K1) in let K14:DEFAULT`Number \u003d MUL1(K12, K12), K24:DEFAULT`Number \u003d MUL2(K22, K22) in let K15:DEFAULT`Number \u003d MUL1(K1, K14), K25:DEFAULT`Number \u003d MUL2(K1, K24) in let K17:DEFAULT`Number \u003d MUL1(K12, K15), K27:DEFAULT`Number \u003d MUL2(K22, K25) in let K19:DEFAULT`Number \u003d MUL1(K12, K17), K29:DEFAULT`Number \u003d MUL2(K22, K27) in let H\u0027:DEFAULT`Number \u003d XOR(K15, K25) in let H5:DEFAULT`Number \u003d MUL2(H\u0027, Q), H7:DEFAULT`Number \u003d XOR(K17, K27), H9:DEFAULT`Number \u003d XOR(K19, K29) in inv_Double_Number([H6, H7]))","type compatibility obligation in \u0027DEFAULT\u0027 (MAASL.vdmsl) at line 181:14: (forall X:DEFAULT`Number, Y:DEFAULT`Number \u0026 let L:int \u003d ((X * Y) mod Maximum_Number_Size_plus_1), U:int \u003d ((X * Y) div Maximum_Number_Size_plus_1) in let D:DEFAULT`Number \u003d ADD(U, U), E:DEFAULT`Number \u003d CAR(U, U) in let F:DEFAULT`Number \u003d ADD(D, (2 * E)) in (inv_Number(L) and is_(L, nat)))","legal function application obligation in \u0027DEFAULT\u0027 (MAASL.vdmsl) at line 209:14: (forall K:DEFAULT`Double_Number \u0026 let X:DEFAULT`Number \u003d (hd K), Y:DEFAULT`Number \u003d (hd (tl K)) in pre_Byte(Y, 3))","non-empty sequence obligation in \u0027DEFAULT\u0027 (MAASL.vdmsl) at line 312:34: (forall K:DEFAULT`Key \u0026 let J1K1:DEFAULT`Double_Number \u003d BYT(K) in let J1:DEFAULT`Number \u003d (hd J1K1), K1:DEFAULT`Number \u003d (hd (tl J1K1)), P:DEFAULT`Number \u003d PAT(K), Q:nat1 \u003d ((1 + P) * (1 + P)) in let J12:DEFAULT`Number \u003d MUL1(J1, J1), J22:DEFAULT`Number \u003d MUL2(J1, J1) in let J14:DEFAULT`Number \u003d MUL1(J12, J12), J24:DEFAULT`Number \u003d MUL2(J22, J22) in let J16:DEFAULT`Number \u003d MUL1(J12, J14), J26:DEFAULT`Number \u003d MUL2(J22, J24) in let J18:DEFAULT`Number \u003d MUL1(J12, J16), J28:DEFAULT`Number \u003d MUL2(J22, J26) in let H4:DEFAULT`Number \u003d XOR(J14, J28), H6:DEFAULT`Number \u003d XOR(J16, J26), H8:DEFAULT`Number \u003d XOR(J18, J28) in let K12:DEFAULT`Number \u003d MUL1(K1, K1), K22:DEFAULT`Number \u003d MUL2(K1, K1) in let K14:DEFAULT`Number \u003d MUL1(K12, K12), K24:DEFAULT`Number \u003d MUL2(K22, K22) in let K15:DEFAULT`Number \u003d MUL1(K1, K14), K25:DEFAULT`Number \u003d MUL2(K1, K24) in let K17:DEFAULT`Number \u003d MUL1(K12, K15), K27:DEFAULT`Number \u003d MUL2(K22, K25) in let K19:DEFAULT`Number \u003d MUL1(K12, K17), K29:DEFAULT`Number \u003d MUL2(K22, K27) in let H\u0027:DEFAULT`Number \u003d XOR(K15, K25) in let H5:DEFAULT`Number \u003d MUL2(H\u0027, Q), H7:DEFAULT`Number \u003d XOR(K17, K27), H9:DEFAULT`Number \u003d XOR(K19, K29) in let X0Y0:DEFAULT`Double_Number \u003d BYT([H4, H5]), V0W:DEFAULT`Double_Number \u003d BYT([H6, H7]), ST:DEFAULT`Double_Number \u003d BYT([H8, H9]) in ((tl X0Y0) \u003c\u003e []))","type invariant satisfiable obligation in \u0027DEFAULT\u0027 (MAASL.vdmsl) at line 65:4: (exists d:DEFAULT`Double_Number \u0026 ((len d) \u003d 2))","type compatibility obligation in \u0027DEFAULT\u0027 (MAASL.vdmsl) at line 148:44: (forall X:DEFAULT`Number, Y:DEFAULT`Number \u0026 ((not ((X \u003d 0) or (Y \u003d 0))) \u003d\u003e (inv_Number((Y div 2)) and is_((Y div 2), nat))))","legal function application obligation in \u0027DEFAULT\u0027 (MAASL.vdmsl) at line 209:24: (forall K:DEFAULT`Double_Number \u0026 let X:DEFAULT`Number \u003d (hd K), Y:DEFAULT`Number \u003d (hd (tl K)) in pre_Byte(Y, 2))","type compatibility obligation in \u0027DEFAULT\u0027 (MAASL.vdmsl) at line 262:19: (forall D:DEFAULT`Double_Number \u0026 let X:DEFAULT`Number \u003d (hd D), Y:DEFAULT`Number \u003d (hd (tl D)) in let X\u0027:seq1 of (DEFAULT`Number) \u003d [Byte(X, 3), Byte(X, 2), Byte(Y, 1), Byte(Y, 0)], Y\u0027:seq1 of (DEFAULT`Number) \u003d [Byte(Y, 3), Byte(Y, 2), Byte(Y, 1), Byte(Y, 0)] in let XY:seq1 of (DEFAULT`Number) \u003d (X\u0027 ^ Y\u0027), P:nat \u003d 0 in (inv_Message_in_blocks(XY) and inv_Message_in_blocks_plus_empty_Message(XY)))","type compatibility obligation in \u0027DEFAULT\u0027 (MAASL.vdmsl) at line 395:53: (forall M:DEFAULT`Message_in_bits, No_bits:nat \u0026 ((((len M) \u003e\u003d No_bits) and (No_bits \u003e\u003d 1)) \u003d\u003e ((not (No_bits \u003d 0)) \u003d\u003e ((No_bits - 1) \u003e\u003d 0))))","non-empty sequence obligation in \u0027DEFAULT\u0027 (MAASL.vdmsl) at line 402:33: (forall M:DEFAULT`Message_in_blocks, No_blocks:nat \u0026 (((len M) \u003e\u003d No_blocks) \u003d\u003e ((not (No_blocks \u003d 0)) \u003d\u003e (M \u003c\u003e []))))","type compatibility obligation in \u0027DEFAULT\u0027 (MAASL.vdmsl) at line 332:24: (forall M:DEFAULT`Message_in_blocks_plus_empty_Message, KC:DEFAULT`Key_Constant \u0026 let mk_Key_Constant(X, Y, V, W, S, T):DEFAULT`Key_Constant \u003d KC in ((not ((len M) \u003d 0)) \u003d\u003e let Mi:DEFAULT`Number \u003d (hd M) in let V\u0027:DEFAULT`Number \u003d CYC(V) in let E:DEFAULT`Number \u003d XOR(V\u0027, W), X\u0027:DEFAULT`Number \u003d XOR(X, Mi), Y\u0027:DEFAULT`Number \u003d XOR(Y, Mi) in let F:DEFAULT`Number \u003d ADD(E, Y\u0027), G:DEFAULT`Number \u003d ADD(E, X\u0027) in inv_Number(A)))","legal function application obligation in \u0027DEFAULT\u0027 (MAASL.vdmsl) at line 337:20: (forall M:DEFAULT`Message_in_blocks_plus_empty_Message, KC:DEFAULT`Key_Constant \u0026 let mk_Key_Constant(X, Y, V, W, S, T):DEFAULT`Key_Constant \u003d KC in ((not ((len M) \u003d 0)) \u003d\u003e let Mi:DEFAULT`Number \u003d (hd M) in let V\u0027:DEFAULT`Number \u003d CYC(V) in let E:DEFAULT`Number \u003d XOR(V\u0027, W), X\u0027:DEFAULT`Number \u003d XOR(X, Mi), Y\u0027:DEFAULT`Number \u003d XOR(Y, Mi) in let F:DEFAULT`Number \u003d ADD(E, Y\u0027), G:DEFAULT`Number \u003d ADD(E, X\u0027) in let F\u0027:DEFAULT`Number \u003d OR(F, A), G\u0027:DEFAULT`Number \u003d OR(G, B) in let F\u0027\u0027:DEFAULT`Number \u003d AND(F\u0027, C), G\u0027\u0027:DEFAULT`Number \u003d AND(G\u0027, D) in pre_MUL2A(Y\u0027, G\u0027\u0027)))","type compatibility obligation in \u0027DEFAULT\u0027 (MAASL.vdmsl) at line 195:28: (forall X:DEFAULT`Number, Y:DEFAULT`Number \u0026 ((((X div Maximum_Number_Size_plus_1_div_2) \u003d 0) or ((Y div Maximum_Number_Size_plus_1_div_2) \u003d 0)) \u003d\u003e let L:int \u003d ((X * Y) mod Maximum_Number_Size_plus_1), U:int \u003d ((X * Y) div Maximum_Number_Size_plus_1) in let D:DEFAULT`Number \u003d ADD(U, U) in let S:DEFAULT`Number \u003d ADD(D, L), C:DEFAULT`Number \u003d CAR(D, L) in inv_Number((2 * C))))","non-zero obligation in \u0027DEFAULT\u0027 (MAASL.vdmsl) at line 221:17: (forall N:DEFAULT`Number, B:nat \u0026 (((B \u003e\u003d 0) and (B \u003c\u003d 3)) \u003d\u003e ((not (B \u003d 0)) \u003d\u003e ((2 ** 8) \u003c\u003e 0))))","non-zero obligation in \u0027DEFAULT\u0027 (MAASL.vdmsl) at line 156:12: (forall X:DEFAULT`Number, Y:DEFAULT`Number \u0026 (Maximum_Number_Size_plus_1 \u003c\u003e 0))","type compatibility obligation in \u0027DEFAULT\u0027 (MAASL.vdmsl) at line 204:4: (forall K:DEFAULT`Double_Number \u0026 inv_Double_Number(let X:DEFAULT`Number \u003d (hd K), Y:DEFAULT`Number \u003d (hd (tl K)) in let X\u0027:seq1 of (DEFAULT`Number) \u003d [Byte(X, 3), Byte(X, 2), Byte(X, 1), Byte(X, 0)], Y\u0027:seq1 of (DEFAULT`Number) \u003d [Byte(Y, 3), Byte(Y, 2), Byte(Y, 1), Byte(X, 0)] in let XY:seq1 of (DEFAULT`Number) \u003d (X\u0027 ^ Y\u0027), P:nat \u003d 0 in let XY\u0027:DEFAULT`Message_in_blocks \u003d Condition_Sequence(XY, P) in let X\u0027\u0027:DEFAULT`Message_in_blocks \u003d Get_head_in_blocks(XY\u0027, 4), Y\u0027\u0027:DEFAULT`Message_in_blocks \u003d Get_tail_in_blocks(XY\u0027, 4) in ([Convert_Bytes_to_Number(X\u0027\u0027)] ^ [Convert_Bytes_to_Number(Y\u0027\u0027)])))","non-empty sequence obligation in \u0027DEFAULT\u0027 (MAASL.vdmsl) at line 252:38: (forall M:DEFAULT`Message_in_blocks \u0026 ((not ((len M) \u003d 1)) \u003d\u003e (M \u003c\u003e [])))","function postcondition satisfiable obligation in \u0027DEFAULT\u0027 (MAASL.vdmsl) at line 96:4: (forall M:DEFAULT`Message_in_bits, No_bits:nat \u0026 (pre_Get_Application_defined_bits(M, No_bits) \u003d\u003e (exists Extra:DEFAULT`Message_in_bits \u0026 post_Get_Application_defined_bits(M, No_bits, Extra))))"]