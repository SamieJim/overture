["function establishes postcondition obligation in \u0027Example3\u0027 (memoryproofPP.vdmpp) at line 83:1: (forall addr:Example3`ADDR, sta:Example3`State \u0026 (pre_AllocSafe0(addr, sta) \u003d\u003e post_AllocSafe0(addr, sta, (Safe(sta) \u003d\u003e Safe(Alloc(addr, sta))))))","type compatibility obligation in \u0027Example3\u0027 (memoryproofPP.vdmpp) at line 32:7: (forall addr:Example3`ADDR, mk_State(mem, access, used):Example3`State \u0026 ((addr not in set used) \u003d\u003e let used\u0027:set of (Example3`ADDR) \u003d (used union {addr}), mem\u0027:map (Example3`ADDR) to (Example3`CON) \u003d (mem ++ {addr |-\u003e let c:Example3`CON in c}) in inv_State(mk_State(mem\u0027, access, used\u0027))))","function establishes postcondition obligation in \u0027Example3\u0027 (memoryproofPP.vdmpp) at line 78:1: (forall addr:Example3`ADDR, sta:Example3`State \u0026 post_AllocSafe(addr, sta, (Safe(sta) \u003d\u003e Safe(Alloc(addr, sta)))))","type compatibility obligation in \u0027Example3\u0027 (memoryproofPP.vdmpp) at line 100:20: inv_State(mk_State({\u003ca0\u003e |-\u003e \u003cc0\u003e}, {\u003ca0\u003e, \u003ca1\u003e}, {\u003ca0\u003e}))","type compatibility obligation in \u0027Example3\u0027 (memoryproofPP.vdmpp) at line 41:7: (forall addr:Example3`ADDR, mk_State(mem, access, used):Example3`State \u0026 (((addr not in set used) and (addr in set access)) \u003d\u003e let used\u0027:set of (Example3`ADDR) \u003d (used union {addr}), mem\u0027:map (Example3`ADDR) to (Example3`CON) \u003d (mem munion {addr |-\u003e let c:Example3`CON in c}) in inv_State(mk_State(mem\u0027, access, used\u0027))))","legal function application obligation in \u0027Example3\u0027 (memoryproofPP.vdmpp) at line 85:24: (forall addr:Example3`ADDR, sta:Example3`State \u0026 ((addr not in set (sta.used)) \u003d\u003e (Safe(sta) \u003d\u003e pre_Alloc(addr, sta))))","let be st existence obligation in \u0027Example3\u0027 (memoryproofPP.vdmpp) at line 58:29: (forall addr:Example3`ADDR, mk_State(-, access, used):Example3`State \u0026 (((addr not in set used) and (addr in set access)) \u003d\u003e (exists c:Example3`CON \u0026 true)))","type compatibility obligation in \u0027Example3\u0027 (memoryproofPP.vdmpp) at line 60:7: (forall addr:Example3`ADDR, mk_State(-, access, used):Example3`State \u0026 (((addr not in set used) and (addr in set access)) \u003d\u003e let used\u0027:set of (Example3`ADDR) \u003d (used union {addr}), mem\u0027:map (Example3`ADDR) to (Example3`CON) \u003d {addr |-\u003e let c:Example3`CON in c} in inv_State(mk_State(mem\u0027, access, used\u0027))))","map compatible obligation in \u0027Example3\u0027 (memoryproofPP.vdmpp) at line 74:14: (forall addr:Example3`ADDR, mk_State(mem, access, used):Example3`State, mem2:map (Example3`ADDR) to (Example3`CON) \u0026 (((addr not in set used) and (addr in set access)) \u003d\u003e let RESULT \u003d let used\u0027:set of (Example3`ADDR) \u003d (used union {addr}), mem\u0027:map (Example3`ADDR) to (Example3`CON) \u003d (mem munion {addr |-\u003e let c:Example3`CON in c}) in mk_State(mem\u0027, access, used\u0027) in (forall ldom1 in set (dom mem), rdom2 in set (dom {addr |-\u003e let c:Example3`CON in c}) \u0026 ((ldom1 \u003d rdom2) \u003d\u003e (mem(ldom1) \u003d {addr |-\u003e let c:Example3`CON in c}(rdom2))))))","type compatibility obligation in \u0027Example3\u0027 (memoryproofPP.vdmpp) at line 71:7: (forall addr:Example3`ADDR, mk_State(mem, access, used):Example3`State, mem2:map (Example3`ADDR) to (Example3`CON) \u0026 (((addr not in set used) and (addr in set access)) \u003d\u003e let used\u0027:set of (Example3`ADDR) \u003d (used union {addr}), mem\u0027:map (Example3`ADDR) to (Example3`CON) \u003d (mem munion {addr |-\u003e let c:Example3`CON in c}) in inv_State(mk_State(mem\u0027, access, used\u0027))))","let be st existence obligation in \u0027Example3\u0027 (memoryproofPP.vdmpp) at line 39:40: (forall addr:Example3`ADDR, mk_State(mem, access, used):Example3`State \u0026 (((addr not in set used) and (addr in set access)) \u003d\u003e (exists c:Example3`CON \u0026 true)))","map compatible obligation in \u0027Example3\u0027 (memoryproofPP.vdmpp) at line 69:15: (forall addr:Example3`ADDR, mk_State(mem, access, used):Example3`State, mem2:map (Example3`ADDR) to (Example3`CON) \u0026 (((addr not in set used) and (addr in set access)) \u003d\u003e (forall ldom1 in set (dom mem), rdom2 in set (dom {addr |-\u003e let c:Example3`CON in c}) \u0026 ((ldom1 \u003d rdom2) \u003d\u003e (mem(ldom1) \u003d {addr |-\u003e let c:Example3`CON in c}(rdom2))))))","let be st existence obligation in \u0027Example3\u0027 (memoryproofPP.vdmpp) at line 30:36: (forall addr:Example3`ADDR, mk_State(mem, access, used):Example3`State \u0026 ((addr not in set used) \u003d\u003e (exists c:Example3`CON \u0026 true)))","type invariant satisfiable obligation in \u0027Example3\u0027 (memoryproofPP.vdmpp) at line 15:1: (exists mk_State(mem, access, used):Example3`State \u0026 (used \u003d (dom mem)))","let be st existence obligation in \u0027Example3\u0027 (memoryproofPP.vdmpp) at line 69:40: (forall addr:Example3`ADDR, mk_State(mem, access, used):Example3`State, mem2:map (Example3`ADDR) to (Example3`CON) \u0026 (((addr not in set used) and (addr in set access)) \u003d\u003e (exists c:Example3`CON \u0026 true)))","function establishes postcondition obligation in \u0027Example3\u0027 (memoryproofPP.vdmpp) at line 65:1: (forall addr:Example3`ADDR, mk_State(mem, access, used):Example3`State, mem2:map (Example3`ADDR) to (Example3`CON) \u0026 (pre_Alloc3(addr, mk_State(mem, access, used), mem2) \u003d\u003e post_Alloc3(addr, mk_State(mem, access, used), mem2, let used\u0027:set of (Example3`ADDR) \u003d (used union {addr}), mem\u0027:map (Example3`ADDR) to (Example3`CON) \u003d (mem munion {addr |-\u003e let c:Example3`CON in c}) in mk_State(mem\u0027, access, used\u0027))))","legal function application obligation in \u0027Example3\u0027 (memoryproofPP.vdmpp) at line 91:24: (forall addr:Example3`ADDR, sta:Example3`State \u0026 (((addr not in set (sta.used)) and (addr in set (sta.access))) \u003d\u003e (Safe(sta) \u003d\u003e pre_Alloc(addr, sta))))","type compatibility obligation in \u0027Example3\u0027 (memoryproofPP.vdmpp) at line 50:7: (forall addr:Example3`ADDR, mk_State(mem, access, used):Example3`State \u0026 (((addr not in set used) and (addr in set access)) \u003d\u003e let used\u0027:set of (Example3`ADDR) \u003d (used union {addr}), mem\u0027:map (Example3`ADDR) to ((\u003cc0\u003e | Example3`CON)) \u003d (mem ++ {addr |-\u003e \u003cc0\u003e}) in inv_State(mk_State(mem\u0027, access, used\u0027))))","function establishes postcondition obligation in \u0027Example3\u0027 (memoryproofPP.vdmpp) at line 89:1: (forall addr:Example3`ADDR, sta:Example3`State \u0026 (pre_AllocSafe2(addr, sta) \u003d\u003e post_AllocSafe2(addr, sta, (Safe(sta) \u003d\u003e Safe(Alloc(addr, sta))))))","map compatible obligation in \u0027Example3\u0027 (memoryproofPP.vdmpp) at line 39:15: (forall addr:Example3`ADDR, mk_State(mem, access, used):Example3`State \u0026 (((addr not in set used) and (addr in set access)) \u003d\u003e (forall ldom1 in set (dom mem), rdom2 in set (dom {addr |-\u003e let c:Example3`CON in c}) \u0026 ((ldom1 \u003d rdom2) \u003d\u003e (mem(ldom1) \u003d {addr |-\u003e let c:Example3`CON in c}(rdom2))))))","legal function application obligation in \u0027Example3\u0027 (memoryproofPP.vdmpp) at line 80:24: (forall addr:Example3`ADDR, sta:Example3`State \u0026 (Safe(sta) \u003d\u003e pre_Alloc(addr, sta)))","let be st existence obligation in \u0027Example3\u0027 (memoryproofPP.vdmpp) at line 74:39: (forall addr:Example3`ADDR, mk_State(mem, access, used):Example3`State, mem2:map (Example3`ADDR) to (Example3`CON) \u0026 (((addr not in set used) and (addr in set access)) \u003d\u003e let RESULT \u003d let used\u0027:set of (Example3`ADDR) \u003d (used union {addr}), mem\u0027:map (Example3`ADDR) to (Example3`CON) \u003d (mem munion {addr |-\u003e let c:Example3`CON in c}) in mk_State(mem\u0027, access, used\u0027) in (exists c:Example3`CON \u0026 true)))"]